var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  debugPrintExpr: () => debugPrintExpr,
  parseVensimEquation: () => parseVensimEquation,
  parseVensimExpr: () => parseVensimExpr,
  parseVensimModel: () => parseVensimModel,
  parseVensimSubscriptRange: () => parseVensimSubscriptRange,
  prettyPrintExpr: () => prettyPrintExpr,
  printExprStats: () => printExprStats,
  reduceConditionals: () => reduceConditionals,
  reduceExpr: () => reduceExpr,
  toPrettyString: () => toPrettyString
});
module.exports = __toCommonJS(src_exports);

// src/ast/print-expr.ts
var import_assert_never = require("assert-never");
function debugPrintExpr(expr, indent = 0) {
  const spaces = " ".repeat(indent * 2);
  const log = (s) => {
    console.log(`${spaces}${s}`);
  };
  switch (expr.kind) {
    case "number":
      log(`const: ${expr.text}`);
      break;
    case "string":
      log(`string: ${expr.text}`);
      break;
    case "keyword":
      log(`keyword: ${expr.text}`);
      break;
    case "variable-ref":
      log(`ref: ${fullIdForVarRef(expr)}`);
      break;
    case "unary-op":
      log(`unary-op: ${expr.op}`);
      debugPrintExpr(expr.expr, indent + 1);
      break;
    case "binary-op":
      log(`binary-op: ${expr.op}`);
      debugPrintExpr(expr.lhs, indent + 1);
      debugPrintExpr(expr.rhs, indent + 1);
      break;
    case "parens":
      log("parens");
      debugPrintExpr(expr.expr, indent + 1);
      break;
    case "lookup-def":
      log(`lookup-def`);
      break;
    case "lookup-call":
      log(`lookup-call: ${debugPrintExpr(expr.varRef)}`);
      debugPrintExpr(expr.arg, indent + 1);
      break;
    case "function-call":
      log(`function-call: ${expr.fnId}`);
      expr.args.forEach((arg) => debugPrintExpr(arg, indent + 1));
      break;
    default:
      (0, import_assert_never.assertNever)(expr);
  }
}
function toPrettyString(expr, opts) {
  let lparen, rparen, spaceSep, commaSep;
  if (opts?.compact === true) {
    lparen = "(";
    rparen = ")";
    spaceSep = "";
    commaSep = ",";
  } else {
    lparen = "( ";
    rparen = " )";
    spaceSep = " ";
    commaSep = ", ";
  }
  switch (expr.kind) {
    case "number":
      return expr.text;
    case "string":
      return `'${expr.text}'`;
    case "keyword":
      return expr.text;
    case "variable-ref":
      if (opts?.formatVariableRef) {
        return opts.formatVariableRef(expr);
      } else {
        if (expr.subscriptRefs?.length > 0) {
          return `${expr.varName}[${expr.subscriptRefs.map((ref) => ref.subName).join(commaSep)}]`;
        } else {
          return expr.varName;
        }
      }
    case "unary-op":
      if (expr.op === ":NOT:") {
        return `${expr.op} ${toPrettyString(expr.expr, opts)}`;
      } else {
        return `${expr.op}${toPrettyString(expr.expr, opts)}`;
      }
    case "binary-op": {
      let op;
      if (opts?.html === true) {
        switch (expr.op) {
          case "<":
            op = "&lt;";
            break;
          case "<=":
            op = "&lt;=";
            break;
          case ">":
            op = "&gt;";
            break;
          case ">=":
            op = "&gt;=";
            break;
          default:
            op = expr.op;
            break;
        }
      } else {
        op = expr.op;
      }
      const lhs = toPrettyString(expr.lhs, opts);
      const rhs = toPrettyString(expr.rhs, opts);
      return `${lhs}${spaceSep}${op}${spaceSep}${rhs}`;
    }
    case "parens":
      return `${lparen}${toPrettyString(expr.expr, opts)}${rparen}`;
    case "lookup-def": {
      const pointString = (p) => {
        return `(${p[0]},${p[1]})`;
      };
      const points = expr.points.map(pointString).join(commaSep);
      if (expr.range) {
        const min = pointString(expr.range.min);
        const max = pointString(expr.range.max);
        return `${lparen}[${min}-${max}]${commaSep}${points}${rparen}`;
      } else {
        return `${lparen}${points}${rparen}`;
      }
    }
    case "lookup-call": {
      const varRef = toPrettyString(expr.varRef, opts);
      const arg = toPrettyString(expr.arg, opts);
      return `${varRef}${lparen}${arg}${rparen}`;
    }
    case "function-call": {
      const args = expr.args.map((arg) => toPrettyString(arg, opts));
      return `${expr.fnName}${lparen}${args.join(commaSep)}${rparen}`;
    }
    default:
      (0, import_assert_never.assertNever)(expr);
  }
}
function prettyPrintExpr(expr, indent = 0) {
  const spaces = " ".repeat(indent * 2);
  const log = (s) => {
    console.log(`${spaces}${s}`);
  };
  log(toPrettyString(expr));
}
var Stats = class {
  constructor() {
    this.constCount = 0;
    this.varRefCount = 0;
    this.unaryOpCounts = /* @__PURE__ */ new Map();
    this.binaryOpCounts = /* @__PURE__ */ new Map();
    this.fnCallCounts = /* @__PURE__ */ new Map();
    this.luCallCounts = /* @__PURE__ */ new Map();
  }
};
function increment(map, key) {
  const count = map.get(key) || 0;
  map.set(key, count + 1);
}
function getExprStats(expr, stats) {
  switch (expr.kind) {
    case "number":
      stats.constCount++;
      break;
    case "string":
      break;
    case "keyword":
      break;
    case "variable-ref":
      stats.varRefCount++;
      break;
    case "unary-op":
      getExprStats(expr.expr, stats);
      increment(stats.unaryOpCounts, expr.op);
      break;
    case "binary-op":
      getExprStats(expr.lhs, stats);
      getExprStats(expr.rhs, stats);
      increment(stats.binaryOpCounts, expr.op);
      break;
    case "parens":
      getExprStats(expr.expr, stats);
      break;
    case "lookup-def":
      break;
    case "lookup-call":
      increment(stats.luCallCounts, fullIdForVarRef(expr.varRef));
      getExprStats(expr.arg, stats);
      break;
    case "function-call":
      increment(stats.fnCallCounts, expr.fnId);
      expr.args.forEach((arg) => getExprStats(arg, stats));
      break;
    default:
      (0, import_assert_never.assertNever)(expr);
  }
}
function printExprStats(exprs) {
  const stats = new Stats();
  for (const expr of exprs) {
    getExprStats(expr, stats);
  }
  function printCount(count, label) {
    console.log(`${count.toString().padStart(6)} ${label}`);
  }
  function printCounts(map) {
    const entries = [...map.entries()].sort((a, b) => a[0].localeCompare(b[0]));
    let total = 0;
    for (const entry of entries) {
      printCount(entry[1], entry[0]);
      total += entry[1];
    }
    printCount(total, "total");
    return total;
  }
  let nodeCount = 0;
  printCount(stats.constCount, "consts");
  nodeCount += stats.constCount;
  printCount(stats.varRefCount, "var refs");
  nodeCount += stats.varRefCount;
  console.log();
  console.log("UNARY OPS");
  nodeCount += printCounts(stats.unaryOpCounts);
  console.log();
  console.log("BINARY OPS");
  nodeCount += printCounts(stats.binaryOpCounts);
  console.log();
  console.log("FUNCTION CALLS");
  nodeCount += printCounts(stats.fnCallCounts);
  console.log();
  console.log("LOOKUP CALLS");
  nodeCount += printCounts(stats.luCallCounts);
  console.log();
  console.log("TOTAL");
  printCount(nodeCount, "nodes");
}
function fullIdForVarRef(varRef) {
  if (varRef.subscriptRefs?.length > 0) {
    return `${varRef.varId}[${varRef.subscriptRefs.map((ref) => ref.subId).join(",")}]`;
  } else {
    return varRef.varId;
  }
}

// src/ast/reduce-expr.ts
var import_assert_never2 = require("assert-never");

// src/_shared/names.js
function canonicalName(name) {
  return "_" + name.trim().replace(/"/g, "_").replace(/\s+!$/g, "!").replace(/\s/g, "_").replace(/,/g, "_").replace(/-/g, "_").replace(/\./g, "_").replace(/\$/g, "_").replace(/'/g, "_").replace(/&/g, "_").replace(/%/g, "_").replace(/\//g, "_").replace(/\|/g, "_").toLowerCase();
}
function cFunctionName(name) {
  return canonicalName(name).toUpperCase();
}

// src/ast/ast-builders.ts
function num(value, text) {
  return {
    kind: "number",
    value,
    text: text || value.toString()
  };
}
function unaryOp(op, expr) {
  return {
    kind: "unary-op",
    op,
    expr
  };
}
function binaryOp(lhs, op, rhs) {
  return {
    kind: "binary-op",
    lhs,
    op,
    rhs
  };
}
function parens(expr) {
  return {
    kind: "parens",
    expr
  };
}
function lookupCall(varRef, arg) {
  return {
    kind: "lookup-call",
    varRef,
    arg
  };
}

// src/ast/reduce-expr.ts
function reduceExpr(expr, opts) {
  switch (expr.kind) {
    case "number":
    case "string":
    case "keyword":
      return expr;
    case "variable-ref":
      if (opts?.resolveVarRef !== void 0) {
        const resolvedExpr = opts.resolveVarRef(expr);
        if (resolvedExpr) {
          return resolvedExpr;
        }
      }
      return expr;
    case "unary-op": {
      const child = reduceExpr(expr.expr, opts);
      switch (expr.op) {
        case "+":
          return child;
        case "-":
          if (child.kind === "number") {
            return num(-child.value);
          } else {
            return unaryOp("-", child);
          }
        case ":NOT:":
          if (child.kind === "number") {
            return num(child.value === 0 ? 1 : 0);
          } else {
            return unaryOp(":NOT:", child);
          }
        default:
          (0, import_assert_never2.assertNever)(expr);
      }
      break;
    }
    case "binary-op": {
      const lhs = reduceExpr(expr.lhs, opts);
      const rhs = reduceExpr(expr.rhs, opts);
      if (lhs.kind === "number" && rhs.kind === "number") {
        switch (expr.op) {
          case "+":
            return num(lhs.value + rhs.value);
          case "-":
            return num(lhs.value - rhs.value);
          case "*":
            return num(lhs.value * rhs.value);
          case "/":
            return num(lhs.value / rhs.value);
          case "^":
            return num(Math.pow(lhs.value, rhs.value));
          case "=":
            return num(lhs.value === rhs.value ? 1 : 0);
          case "<>":
            return num(lhs.value !== rhs.value ? 1 : 0);
          case "<":
            return num(lhs.value < rhs.value ? 1 : 0);
          case ">":
            return num(lhs.value > rhs.value ? 1 : 0);
          case "<=":
            return num(lhs.value <= rhs.value ? 1 : 0);
          case ">=":
            return num(lhs.value >= rhs.value ? 1 : 0);
          case ":AND:":
            return num(lhs.value !== 0 && rhs.value !== 0 ? 1 : 0);
          case ":OR:":
            return num(lhs.value !== 0 || rhs.value !== 0 ? 1 : 0);
          default:
            (0, import_assert_never2.assertNever)(expr);
        }
      } else if (lhs.kind === "number" || rhs.kind === "number") {
        const lhsNum = lhs.kind === "number" ? lhs.value : void 0;
        const rhsNum = rhs.kind === "number" ? rhs.value : void 0;
        const numValue = lhsNum !== void 0 ? lhsNum : rhsNum;
        const otherSide = lhsNum !== void 0 ? rhs : lhs;
        switch (expr.op) {
          case "+": {
            if (numValue === 0) {
              return otherSide;
            } else if (otherSide.kind === "binary-op" && otherSide.op === "+" && (otherSide.lhs.kind === "number" || otherSide.rhs.kind === "number")) {
              const otherSideLhsNum = otherSide.lhs.kind === "number" ? otherSide.lhs.value : void 0;
              const otherSideRhsNum = otherSide.rhs.kind === "number" ? otherSide.rhs.value : void 0;
              const otherSideConstValue = otherSideLhsNum !== void 0 ? otherSideLhsNum : otherSideRhsNum;
              const otherSideOtherPart = otherSideLhsNum !== void 0 ? otherSide.rhs : otherSide.lhs;
              return binaryOp(num(numValue + otherSideConstValue), "+", otherSideOtherPart);
            }
            break;
          }
          case "-": {
            if (rhsNum === 0) {
              return lhs;
            } else if (lhsNum === 0) {
              return unaryOp("-", rhs);
            }
            break;
          }
          case "*": {
            if (numValue === 0) {
              return num(0);
            } else if (numValue === 1) {
              return otherSide;
            } else if (otherSide.kind === "binary-op" && otherSide.op === "*" && (otherSide.lhs.kind === "number" || otherSide.rhs.kind === "number")) {
              const otherSideLhsNum = otherSide.lhs.kind === "number" ? otherSide.lhs.value : void 0;
              const otherSideRhsNum = otherSide.rhs.kind === "number" ? otherSide.rhs.value : void 0;
              const otherSideConstValue = otherSideLhsNum !== void 0 ? otherSideLhsNum : otherSideRhsNum;
              const otherSideOtherPart = otherSideLhsNum !== void 0 ? otherSide.rhs : otherSide.lhs;
              return binaryOp(num(numValue * otherSideConstValue), "*", otherSideOtherPart);
            }
            break;
          }
          case "/": {
            if (rhsNum === 1) {
              return lhs;
            }
            break;
          }
          case "^": {
            if (rhsNum === 0) {
              return num(1);
            } else if (rhsNum === 1) {
              return lhs;
            }
            break;
          }
          case ":AND:":
            return numValue === 0 ? num(0) : otherSide;
          case ":OR:":
            return numValue !== 0 ? num(1) : otherSide;
          default:
            break;
        }
      }
      return {
        kind: "binary-op",
        lhs,
        op: expr.op,
        rhs
      };
    }
    case "parens": {
      const child = reduceExpr(expr.expr, opts);
      return applyParens(child);
    }
    case "lookup-def":
      return expr;
    case "lookup-call":
      return expr;
    case "function-call": {
      if (expr.fnId === "_IF_THEN_ELSE") {
        const conditionExpr = reduceExpr(expr.args[0], opts);
        if (conditionExpr.kind === "number") {
          const branchExpr = conditionExpr.value !== 0 ? reduceExpr(expr.args[1], opts) : reduceExpr(expr.args[2], opts);
          return applyParens(branchExpr);
        }
      }
      const reducedArgs = expr.args.map((arg) => reduceExpr(arg, opts));
      const allConst = reducedArgs.every((arg) => arg.kind === "number");
      if (allConst) {
        const constArg = (index) => {
          const num2 = reducedArgs[index];
          return num2.value;
        };
        switch (expr.fnId) {
          case "_ABS":
            return num(Math.abs(constArg(0)));
          case "_COS":
            return num(Math.cos(constArg(0)));
          case "_EXP":
            return num(Math.exp(constArg(0)));
          case "_INITIAL":
            return reducedArgs[0];
          case "_INTEGER":
            return num(Math.trunc(constArg(0)));
          case "_LN":
            return num(Math.log(constArg(0)));
          case "_MAX":
            return num(Math.max(constArg(0), constArg(1)));
          case "_MIN":
            return num(Math.min(constArg(0), constArg(1)));
          case "_MODULO":
            return num(constArg(0) % constArg(1));
          case "_POWER":
            return num(Math.pow(constArg(0), constArg(1)));
          case "_SIN":
            return num(Math.sin(constArg(0)));
          case "_SQRT":
            return num(Math.sqrt(constArg(0)));
          default:
            break;
        }
      }
      return {
        kind: "function-call",
        fnName: expr.fnName,
        fnId: expr.fnId,
        args: reducedArgs
      };
    }
    default:
      (0, import_assert_never2.assertNever)(expr);
  }
}
function reduceConditionals(expr, opts) {
  switch (expr.kind) {
    case "number":
    case "string":
    case "keyword":
      return expr;
    case "variable-ref":
      return expr;
    case "unary-op": {
      const child = reduceConditionals(expr.expr, opts);
      return unaryOp(expr.op, child);
    }
    case "binary-op": {
      const lhs = reduceConditionals(expr.lhs, opts);
      const rhs = reduceConditionals(expr.rhs, opts);
      return binaryOp(lhs, expr.op, rhs);
    }
    case "parens": {
      const child = reduceConditionals(expr.expr, opts);
      return applyParens(child);
    }
    case "lookup-def":
      return expr;
    case "lookup-call": {
      const arg = reduceConditionals(expr.arg, opts);
      return lookupCall(expr.varRef, arg);
    }
    case "function-call": {
      if (expr.fnId === "_IF_THEN_ELSE") {
        const conditionExpr = reduceExpr(expr.args[0], opts);
        if (conditionExpr.kind === "number") {
          const branchExpr = conditionExpr.value !== 0 ? reduceConditionals(expr.args[1], opts) : reduceConditionals(expr.args[2], opts);
          return applyParens(branchExpr);
        }
      }
      const reducedArgs = expr.args.map((arg) => reduceConditionals(arg, opts));
      return {
        kind: "function-call",
        fnName: expr.fnName,
        fnId: expr.fnId,
        args: reducedArgs
      };
    }
    default:
      (0, import_assert_never2.assertNever)(expr);
  }
}
function applyParens(child) {
  switch (child.kind) {
    case "number":
    case "string":
    case "keyword":
    case "variable-ref":
      return child;
    default:
      return parens(child);
  }
}

// src/vensim/impl/subscript-range-reader.js
var import_antlr4_vensim2 = require("antlr4-vensim");

// src/vensim/impl/antlr-parser.js
var import_antlr4 = __toESM(require("antlr4"), 1);
var import_antlr4_vensim = require("antlr4-vensim");
function createAntlrParser(input) {
  const errorListener = new CustomErrorListener(input);
  let chars = new import_antlr4.default.InputStream(input);
  let lexer = new import_antlr4_vensim.ModelLexer(chars);
  lexer.removeErrorListeners();
  lexer.addErrorListener(errorListener);
  let tokens = new import_antlr4.default.CommonTokenStream(lexer);
  let parser = new import_antlr4_vensim.ModelParser(tokens);
  parser.buildParseTrees = true;
  parser.removeErrorListeners();
  parser.addErrorListener(errorListener);
  return parser;
}
var CustomErrorListener = class extends import_antlr4.default.error.ErrorListener {
  constructor(input) {
    super();
    this.input = input;
  }
  syntaxError(_recognizer, _offendingSymbol, line, column, msg) {
    throw new Error(msg, {
      cause: {
        code: "VensimParseError",
        line,
        column
      }
    });
  }
};

// src/vensim/impl/subscript-range-reader.js
var SubscriptRangeReader = class extends import_antlr4_vensim2.ModelVisitor {
  /**
   * @public
   * @param {import('../vensim-parse-context').VensimParseContext} parseContext An object
   * that provides access to file system resources (such as external data files) that are
   * referenced during the parse phase.
   */
  constructor(parseContext) {
    super();
    this.parseContext = parseContext;
  }
  /**
   * Parse the given Vensim subscript range definition and return a `DimensionDef` AST node.
   *
   * @public
   * @param {string} subscriptRangeText A string containing the Vensim subscript range definition.
   * @returns {import('../../ast/ast-types').DimensionDef} A `DimensionDef` AST node.
   */
  /*public*/
  parse(subscriptRangeText) {
    const parser = createAntlrParser(subscriptRangeText);
    const subscriptRangeCtx = parser.subscriptRange();
    return this.visitSubscriptRange(subscriptRangeCtx);
  }
  /**
   * Process the given ANTLR `SubscriptRangeContext` from an already parsed Vensim
   * subscript range definition.
   *
   * @public
   * @param {import('antlr4-vensim').SubscriptRangeContext} ctx The ANTLR `SubscriptRangeContext`.
   * @returns {import('../../ast/ast-types').Expr} A `SubscriptRange` AST node.
   */
  /*public*/
  visitSubscriptRange(ctx) {
    this.subscriptNames = [];
    this.subscriptMappings = [];
    const comment = "";
    const ids = ctx.Id();
    if (ids.length === 1) {
      const dimName = ids[0].getText();
      const dimId = canonicalName(dimName);
      super.visitSubscriptRange(ctx);
      return {
        dimName,
        dimId,
        familyName: dimName,
        familyId: dimId,
        subscriptRefs: this.subscriptNames.map((subName) => {
          return {
            subName,
            subId: canonicalName(subName)
          };
        }),
        subscriptMappings: this.subscriptMappings,
        comment
      };
    } else if (ids.length === 2) {
      const dimName = ids[0].getText();
      const dimId = canonicalName(dimName);
      const familyName = ids[1].getText();
      const familyId = canonicalName(familyName);
      return {
        dimName,
        dimId,
        familyName,
        familyId,
        subscriptRefs: [],
        subscriptMappings: [],
        comment
      };
    }
  }
  visitSubscriptDefList(ctx) {
    for (const subscriptDef of ctx.children) {
      if (subscriptDef.symbol?.type === import_antlr4_vensim2.ModelParser.Id) {
        this.subscriptNames.push(subscriptDef.getText());
      } else if (subscriptDef.ruleIndex === import_antlr4_vensim2.ModelParser.RULE_subscriptSequence) {
        this.visitSubscriptSequence(subscriptDef);
      }
    }
  }
  visitSubscriptSequence(ctx) {
    const re = /^(.*?)(\d+)$/;
    const ids = ctx.Id().map((id) => id.getText());
    const matches = ids.map((id) => re.exec(id));
    if (matches[0][1] === matches[1][1]) {
      const prefix = matches[0][1];
      const start = parseInt(matches[0][2]);
      const end = parseInt(matches[1][2]);
      for (let i = start; i <= end; i++) {
        this.subscriptNames.push(prefix + i);
      }
    }
  }
  visitSubscriptMapping(ctx) {
    const toDimName = ctx.Id().getText();
    this.mappedSubscriptNames = [];
    super.visitSubscriptMapping(ctx);
    this.subscriptMappings.push({
      toDimName,
      toDimId: canonicalName(toDimName),
      subscriptRefs: this.mappedSubscriptNames.map((subName) => {
        return {
          subName,
          subId: canonicalName(subName)
        };
      })
    });
  }
  visitSubscriptList(ctx) {
    this.mappedSubscriptNames = ctx.Id().map((id) => id.getText());
  }
  visitCall(ctx) {
    const fnName = ctx.Id().getText();
    const fnId = cFunctionName(fnName);
    if (fnId === "_GET_DIRECT_SUBSCRIPT") {
      super.visitCall(ctx);
    } else {
      throw new Error(
        `Only 'GET DIRECT SUBSCRIPT' calls are supported in subscript range definitions, but saw '${fnName}'`
      );
    }
  }
  visitExprList(ctx) {
    const args = ctx.expr().map((expr) => {
      const exprText = expr.getText();
      return exprText.replaceAll("'", "");
    });
    const fileName = args[0];
    const tabOrDelimiter = args[1];
    const firstCell = args[2];
    const lastCell = args[3];
    const prefix = args[4];
    this.subscriptNames = this.parseContext?.getDirectSubscripts(fileName, tabOrDelimiter, firstCell, lastCell, prefix) || [];
  }
};

// src/vensim/parse-vensim-subscript-range.ts
function parseVensimSubscriptRange(input, context) {
  const subscriptReader = new SubscriptRangeReader(context);
  return subscriptReader.parse(input);
}

// src/vensim/impl/expr-reader.js
var import_antlr4_vensim3 = require("antlr4-vensim");
var ExprReader = class extends import_antlr4_vensim3.ModelVisitor {
  constructor() {
    super();
    this.callStack = [];
  }
  /**
   * Parse the given Vensim expression definition and return an `Expr` AST node.
   *
   * @public
   * @param {string} exprText A string containing the Vensim expression.
   * @returns {import('../../ast/ast-types').Expr} An `Expr` AST node.
   */
  /*public*/
  parse(exprText) {
    const parser = createAntlrParser(exprText);
    const exprCtx = parser.expr();
    return this.visitExpr(exprCtx);
  }
  /**
   * Process the given ANTLR `ExprContext` from an already parsed Vensim
   * expression definition.
   *
   * @public
   * @param {import('antlr4-vensim').ExprContext} ctx The ANTLR `ExprContext`.
   * @returns {import('../../ast/ast-types').Expr} An `Expr` AST node.
   */
  /*public*/
  visitExpr(ctx) {
    ctx.accept(this);
    return this.expr;
  }
  //
  // Constants
  //
  visitConst(ctx) {
    const text = ctx.Const().getText();
    if (text.startsWith("'") && text.endsWith("'")) {
      this.expr = {
        kind: "string",
        text: text.substr(1, text.length - 2)
      };
    } else {
      const value = parseFloat(text);
      this.expr = {
        kind: "number",
        value,
        text
      };
    }
  }
  //
  // Keywords
  //
  visitKeyword(ctx) {
    const text = ctx.Keyword().getText();
    this.expr = {
      kind: "keyword",
      text
    };
  }
  //
  // Function calls and variables
  //
  visitCall(ctx) {
    const vensimFnName = ctx.Id().getText();
    const fnId = cFunctionName(vensimFnName);
    this.callStack.push({ fn: fnId, args: [] });
    super.visitCall(ctx);
    const callInfo = this.callStack.pop();
    this.expr = {
      kind: "function-call",
      fnName: vensimFnName,
      fnId,
      args: callInfo.args
    };
  }
  visitExprList(ctx) {
    const exprs = ctx.expr();
    for (let i = 0; i < exprs.length; i++) {
      exprs[i].accept(this);
      const n = this.callStack.length;
      if (n > 0) {
        this.callStack[n - 1].args.push(this.expr);
      }
    }
  }
  visitVar(ctx) {
    const vensimVarName = ctx.Id().getText().trim();
    const varId = canonicalName(vensimVarName);
    this.subscripts = void 0;
    super.visitVar(ctx);
    const subscriptNames = this.subscripts;
    const subscriptRefs = subscriptNames?.map((name) => {
      return {
        subName: name,
        subId: canonicalName(name)
      };
    });
    this.subscripts = void 0;
    this.expr = {
      kind: "variable-ref",
      varName: vensimVarName,
      varId,
      subscriptRefs
    };
  }
  visitSubscriptList(ctx) {
    this.subscripts = ctx.Id().map((id) => id.getText());
  }
  //
  // Lookups
  //
  getPoint(lookupPoint) {
    const exprs = lookupPoint.expr();
    if (exprs.length >= 2) {
      return [parseFloat(exprs[0].getText()), parseFloat(exprs[1].getText())];
    }
  }
  visitLookupRange(ctx) {
    this.lookupRange = ctx.lookupPoint().map((p) => this.getPoint(p));
    super.visitLookupRange(ctx);
  }
  visitLookupPointList(ctx) {
    this.lookupPoints = ctx.lookupPoint().map((p) => this.getPoint(p));
    super.visitLookupPointList(ctx);
  }
  visitLookupArg(ctx) {
    super.visitLookupArg(ctx);
    let range;
    if (this.lookupRange && this.lookupRange.length === 2) {
      range = {
        min: this.lookupRange[0],
        max: this.lookupRange[1]
      };
    }
    this.expr = {
      kind: "lookup-def",
      range,
      points: this.lookupPoints
    };
    this.lookupRange = void 0;
    this.lookupPoints = void 0;
  }
  visitLookupCall(ctx) {
    const lookupVarName = ctx.Id().getText();
    const lookupVarId = canonicalName(lookupVarName);
    if (ctx.subscriptList()) {
      ctx.subscriptList().accept(this);
    }
    const subscriptNames = this.subscripts;
    const subscriptRefs = subscriptNames?.map((name) => {
      return {
        subName: name,
        subId: canonicalName(name)
      };
    });
    this.subscripts = void 0;
    const lookupVarRef = {
      kind: "variable-ref",
      varName: lookupVarName,
      varId: lookupVarId,
      subscriptRefs
    };
    ctx.expr().accept(this);
    const lookupArg = this.expr;
    this.expr = {
      kind: "lookup-call",
      varRef: lookupVarRef,
      arg: lookupArg
    };
  }
  //
  // Unary operators
  //
  completeUnary(op) {
    const child = this.expr;
    this.expr = {
      kind: "unary-op",
      op,
      expr: child
    };
  }
  visitNegative(ctx) {
    super.visitNegative(ctx);
    this.completeUnary("-");
  }
  visitPositive(ctx) {
    super.visitPositive(ctx);
    this.completeUnary("+");
  }
  visitNot(ctx) {
    super.visitNot(ctx);
    this.completeUnary(":NOT:");
  }
  //
  // Binary operators
  //
  visitBinaryArgs(ctx, op) {
    ctx.expr(0).accept(this);
    const lhs = this.expr;
    ctx.expr(1).accept(this);
    const rhs = this.expr;
    this.expr = {
      kind: "binary-op",
      lhs,
      op,
      rhs
    };
  }
  visitPower(ctx) {
    this.visitBinaryArgs(ctx, "^");
  }
  visitMulDiv(ctx) {
    this.visitBinaryArgs(ctx, ctx.op.type === import_antlr4_vensim3.ModelLexer.Star ? "*" : "/");
  }
  visitAddSub(ctx) {
    this.visitBinaryArgs(ctx, ctx.op.type === import_antlr4_vensim3.ModelLexer.Plus ? "+" : "-");
  }
  visitRelational(ctx) {
    let op;
    switch (ctx.op.type) {
      case import_antlr4_vensim3.ModelLexer.Less:
        op = "<";
        break;
      case import_antlr4_vensim3.ModelLexer.Greater:
        op = ">";
        break;
      case import_antlr4_vensim3.ModelLexer.LessEqual:
        op = "<=";
        break;
      case import_antlr4_vensim3.ModelLexer.GreaterEqual:
        op = ">=";
        break;
      default:
        throw new Error(`Unexpected relational operator '${op}'`);
    }
    this.visitBinaryArgs(ctx, op);
  }
  visitEquality(ctx) {
    this.visitBinaryArgs(ctx, ctx.op.type === import_antlr4_vensim3.ModelLexer.Equal ? "=" : "<>");
  }
  visitAnd(ctx) {
    this.visitBinaryArgs(ctx, ":AND:");
  }
  visitOr(ctx) {
    this.visitBinaryArgs(ctx, ":OR:");
  }
  //
  // Tokens
  //
  visitParens(ctx) {
    super.visitParens(ctx);
    const child = this.expr;
    this.expr = {
      kind: "parens",
      expr: child
    };
  }
};

// src/vensim/parse-vensim-expr.ts
function parseVensimExpr(input) {
  const exprReader = new ExprReader();
  return exprReader.parse(input);
}

// src/vensim/impl/equation-reader.js
var import_antlr4_vensim4 = require("antlr4-vensim");
var EquationReader = class extends import_antlr4_vensim4.ModelVisitor {
  constructor() {
    super();
  }
  /**
   * Parse the given Vensim equation definition and return an `Equation` AST node.
   *
   * @public
   * @param {string} equationText A string containing the Vensim equation definition.
   * @return {import('../../ast/ast-types').Equation} An `Equation` AST node.
   */
  /*public*/
  parse(equationText) {
    const parser = createAntlrParser(equationText);
    const equationCtx = parser.equation();
    return this.visitEquation(equationCtx);
  }
  /**
   * Process the given ANTLR `EquationContext` from an already parsed Vensim
   * equation definition.
   *
   * @public
   * @param {import('antlr4-vensim').EquationContext} ctx The ANTLR `EquationContext`.
   * @returns {import('../../ast/ast-types').Equation} An `Equation` AST node.
   */
  /*public*/
  visitEquation(ctx) {
    this.equationLhs = void 0;
    this.lookupDef = void 0;
    ctx.lhs().accept(this);
    let equationRhs;
    const exprCtx = ctx.expr();
    if (exprCtx) {
      const exprReader = new ExprReader();
      const expr = exprReader.visitExpr(exprCtx);
      equationRhs = {
        kind: "expr",
        expr
      };
    } else if (ctx.constList()) {
      ctx.constList().accept(this);
      equationRhs = {
        kind: "const-list",
        constants: this.constants,
        text: this.constListText
      };
    } else if (ctx.lookup()) {
      ctx.lookup().accept(this);
      equationRhs = {
        kind: "lookup",
        lookupDef: this.lookupDef
      };
    } else {
      equationRhs = {
        kind: "data"
      };
    }
    if (this.equationLhs) {
      this.equation = {
        lhs: this.equationLhs,
        rhs: equationRhs,
        // TODO: For now, fill in an empty string for these two; this is mainly
        // for compatibility with unit tests that expect empty string instead of
        // undefined, but this should be revisited
        units: "",
        comment: ""
      };
    }
    return this.equation;
  }
  visitSubscriptList(ctx) {
    if (this.subscripts === void 0) {
      this.subscripts = ctx.Id().map((id) => id.getText());
    } else {
      if (this.exceptSubscriptSets === void 0) {
        this.exceptSubscriptSets = [];
      }
      this.exceptSubscriptSets.push(ctx.Id().map((id) => id.getText()));
    }
  }
  visitLhs(ctx) {
    const lhsVarName = ctx.Id().getText();
    const lhsVarId = canonicalName(lhsVarName);
    super.visitLhs(ctx);
    const subscriptNames = this.subscripts;
    const subscriptRefs = subscriptNames?.map((name) => {
      return {
        subName: name,
        subId: canonicalName(name)
      };
    });
    const exceptSubscriptSets = this.exceptSubscriptSets;
    const exceptSubscriptRefSets = exceptSubscriptSets?.map((subscriptSet) => {
      return subscriptSet.map((name) => {
        return {
          subName: name,
          subId: canonicalName(name)
        };
      });
    });
    this.subscripts = void 0;
    this.exceptSubscripts = void 0;
    this.equationLhs = {
      varDef: {
        kind: "variable-def",
        varName: lhsVarName,
        varId: lhsVarId,
        subscriptRefs,
        exceptSubscriptRefSets
      }
    };
  }
  //
  // CONST LISTS
  //
  visitConstList(ctx) {
    this.constants = ctx.expr().map((expr) => {
      const text = expr.getText();
      const value = parseFloat(text);
      return {
        kind: "number",
        value,
        text
      };
    });
    this.constListText = ctx.getText();
  }
  //
  // LOOKUPS
  //
  getPoint(lookupPoint) {
    const exprs = lookupPoint.expr();
    if (exprs.length >= 2) {
      return [parseFloat(exprs[0].getText()), parseFloat(exprs[1].getText())];
    }
  }
  visitLookup(ctx) {
    this.lookupRange = void 0;
    this.lookupPoints = void 0;
    if (ctx.lookupRange()) {
      ctx.lookupRange().accept(this);
    }
    if (ctx.lookupPointList()) {
      ctx.lookupPointList().accept(this);
    }
    let range;
    if (this.lookupRange && this.lookupRange.length === 2) {
      range = {
        min: this.lookupRange[0],
        max: this.lookupRange[1]
      };
    }
    this.lookupDef = {
      kind: "lookup-def",
      range,
      points: this.lookupPoints
    };
  }
  visitLookupRange(ctx) {
    this.lookupRange = ctx.lookupPoint().map((p) => this.getPoint(p));
    super.visitLookupRange(ctx);
  }
  visitLookupPointList(ctx) {
    this.lookupPoints = ctx.lookupPoint().map((p) => this.getPoint(p));
    super.visitLookupPointList(ctx);
  }
};

// src/vensim/parse-vensim-equation.ts
function parseVensimEquation(input) {
  const equationReader = new EquationReader();
  return equationReader.parse(input);
}

// src/vensim/preprocess-vensim.ts
var import_split_string = __toESM(require("split-string"), 1);
function preprocessVensimModel(input) {
  const rawDefs = splitDefs(input);
  const vensimDefs = [];
  for (const rawDef of rawDefs) {
    const vensimDef = processDef(rawDef);
    if (vensimDef) {
      vensimDefs.push(vensimDef);
    }
  }
  return vensimDefs;
}
function splitDefs(input) {
  const defTexts = (0, import_split_string.default)(input, { separator: "|", quotes: ['"'], keep: () => true });
  const rawDefs = [];
  let lineNum = 1;
  let currentGroup;
  for (let defText of defTexts) {
    if (lineNum === 1) {
      defText = defText.replace("{UTF-8}", "");
    }
    if (defText.includes("\\---/// Sketch")) {
      break;
    }
    const parts = defText.match(/(\s*)(.*)/ms);
    const leadingLineBreaks = parts[1]?.match(/\r\n|\n|\r/gm);
    lineNum += leadingLineBreaks?.length || 0;
    if (defText.includes("********************************************************")) {
      const groupLines = splitLines(defText).filter((s) => s.trim().length > 0);
      currentGroup = void 0;
      if (groupLines.length > 1) {
        const groupNameLine = groupLines[1];
        const groupNameParts = groupNameLine.match(/^\s*\.(.*)$/);
        if (groupNameParts) {
          currentGroup = groupNameParts[1];
        }
      }
    } else {
      rawDefs.push({
        text: defText,
        line: lineNum,
        group: currentGroup
      });
    }
    const contentLineBreaks = parts[2]?.match(/\r\n|\n|\r/gm);
    lineNum += contentLineBreaks?.length || 0;
  }
  return rawDefs;
}
function splitLines(input) {
  return input.split(/\r\n|\n|\r/);
}
function processBackslashes(input) {
  const inputLines = splitLines(input);
  let output = "";
  let prevLine = "";
  for (let line of inputLines) {
    if (prevLine !== "") {
      line = prevLine + line.trim();
      prevLine = "";
    }
    const continuation = line.match(/\\\s*$/);
    if (continuation) {
      prevLine = line.substr(0, continuation.index).replace(/\s+$/, " ");
    } else {
      output += line + "\n";
    }
  }
  return output;
}
function replaceDelimitedStrings(str, open, close, newStr) {
  let result = "";
  let start = 0;
  let depth = 0;
  const n = str.length;
  for (let i = 0; i < n; i++) {
    if (str.charAt(i) === open) {
      if (depth === 0) {
        result += str.substring(start, i);
      }
      depth++;
    } else if (str.charAt(i) === close && depth > 0) {
      depth--;
      if (depth === 0) {
        result += newStr;
        start = i + 1;
      }
    }
  }
  if (start < n) {
    result += str.substring(start);
  }
  return result;
}
function reduceWhitespace(input) {
  return input.replace(/\s\s+/g, " ").trim();
}
function keyForDef(def) {
  let key = def;
  key = key.replace(/:INTERPOLATE:/g, "");
  if (key.includes("=")) {
    key = key.split("=")[0].trim();
  } else if (key.includes(":")) {
    key = key.split(":")[0].trim();
  } else {
  }
  key = key.replace(/"/g, "");
  key = key.split("(")[0];
  key = key.trim();
  key = key.replace(/\[\s*/g, "[");
  key = key.replace(/\s*\]/g, "]");
  key = key.toLowerCase();
  return key;
}
function processDef(rawDef) {
  let input = rawDef.text;
  input = input.replace(/:RAW:/g, "");
  input = replaceDelimitedStrings(input, "{", "}", "");
  input = input.trim();
  if (input.length === 0) {
    return void 0;
  }
  input = processBackslashes(input);
  const parts = input.split("~");
  if (parts.length < 3) {
    throw new Error(`Found invalid model definition during preprocessing (missing comment delimiters?):

${input}`);
  }
  const rawDefText = reduceWhitespace(parts[0]);
  const key = keyForDef(rawDefText);
  const def = `${rawDefText} ~~|`;
  const units = reduceWhitespace(parts[1]);
  const comment = reduceWhitespace(parts[2]);
  const group = rawDef.group;
  return {
    key,
    def,
    line: rawDef.line,
    units,
    comment,
    ...group ? { group } : {}
  };
}

// src/vensim/impl/model-reader.js
var import_antlr4_vensim5 = require("antlr4-vensim");
var ModelReader = class extends import_antlr4_vensim5.ModelVisitor {
  /**
   * @public
   * @param {import('../vensim-parse-context').VensimParseContext} parseContext An object
   * that provides access to file system resources (such as external data files) that are
   * referenced during the parse phase.
   */
  constructor(parseContext) {
    super();
    this.parseContext = parseContext;
    this.dimensions = [];
    this.equations = [];
  }
  /**
   * Parse the given Vensim model definition and return a `Model` AST node.
   *
   * @public
   * @param {string} modelText A string containing the Vensim model.
   * @returns {import('../../ast/ast-types').Model} A `Model` AST node.
   */
  /*public*/
  parse(modelText) {
    const parser = createAntlrParser(modelText);
    const modelCtx = parser.model();
    modelCtx.accept(this);
    return this.model;
  }
  visitModel(ctx) {
    const subscriptRangesCtx = ctx.subscriptRange();
    if (subscriptRangesCtx) {
      const subscriptReader = new SubscriptRangeReader(this.parseContext);
      for (const subscriptRangeCtx of subscriptRangesCtx) {
        const dimensionDef = subscriptReader.visitSubscriptRange(subscriptRangeCtx);
        this.dimensions.push(dimensionDef);
      }
    }
    const equationsCtx = ctx.equation();
    if (equationsCtx) {
      const equationReader = new EquationReader();
      for (const equationCtx of equationsCtx) {
        const equation = equationReader.visitEquation(equationCtx);
        this.equations.push(equation);
      }
    }
    this.model = {
      dimensions: this.dimensions,
      equations: this.equations
    };
  }
};

// src/vensim/parse-vensim-model.ts
function parseVensimModel(input, context, sort = false) {
  const dimensions = [];
  const equations = [];
  const defs = preprocessVensimModel(input);
  if (sort) {
    defs.sort((a, b) => {
      return a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
    });
  }
  for (const def of defs) {
    let parsedModel;
    try {
      const modelReader = new ModelReader(context);
      parsedModel = modelReader.parse(def.def);
    } catch (e) {
      let linePart = "";
      if (e.cause?.code === "VensimParseError") {
        if (e.cause.line) {
          linePart += ` at line ${e.cause.line - 1 + def.line}`;
          if (e.cause.column) {
            linePart += `, col ${e.cause.column}`;
          }
        }
      }
      const msg = `Failed to parse Vensim model definition${linePart}:
${def.def}

Detail:
  ${e.message}`;
      throw new Error(msg);
    }
    for (const dimensionDef of parsedModel.dimensions) {
      const group = def.group;
      dimensions.push({
        ...dimensionDef,
        comment: def.comment,
        ...group ? { group } : {}
      });
    }
    for (const equation of parsedModel.equations) {
      const group = def.group;
      equations.push({
        ...equation,
        units: def.units,
        comment: def.comment,
        ...group ? { group } : {}
      });
    }
  }
  return {
    dimensions,
    equations
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  debugPrintExpr,
  parseVensimEquation,
  parseVensimExpr,
  parseVensimModel,
  parseVensimSubscriptRange,
  prettyPrintExpr,
  printExprStats,
  reduceConditionals,
  reduceExpr,
  toPrettyString
});
//# sourceMappingURL=index.cjs.map