{"version":3,"sources":["../src/index.ts","../src/runner.ts","../src/worker.ts"],"sourcesContent":["// Copyright (c) 2020-2022 Climate Interactive / New Venture Fund\n\nexport { spawnAsyncModelRunner } from './runner'\n\nexport { exposeModelWorker } from './worker'\n","// Copyright (c) 2020-2022 Climate Interactive / New Venture Fund\n\nimport { BlobWorker, spawn, Thread, Transfer, Worker } from 'threads'\n\nimport type { ModelRunner } from '@sdeverywhere/runtime'\nimport { BufferedRunModelParams, ModelListing, Outputs } from '@sdeverywhere/runtime'\n\n/**\n * Initialize a `ModelRunner` that runs the model asynchronously in a worker\n * (a Web Worker when running in a browser environment, or a worker thread\n * when running in a Node.js environment).\n *\n * In your app project, define a JavaScript file, called `worker.js` for example,\n * that initializes the generated model in the context of a worker thread:\n *\n * ```js\n * import { exposeModelWorker } from '@sdeverywhere/runtime-async/worker'\n * import loadGeneratedModel from './sde-prep/generated-model.js'\n *\n * exposeModelWorker(loadGeneratedModel)\n * ```\n *\n * Then, in your web app, call the `spawnAsyncModelRunner` function, which\n * will spawn the worker thread and initialize the `ModelRunner` that communicates\n * with the worker:\n *\n * ```js\n * import { spawnAsyncModelRunner } from '@sdeverywhere/runtime-async/runner'\n *\n * async function initApp() {\n *   // ...\n *   const runner = await spawnAsyncModelRunner({ path: './worker.js' })\n *   // ...\n * }\n * ```\n *\n * @param workerSpec Either a `path` to the worker JavaScript file, or the `source`\n * containing the full JavaScript source of the worker.\n */\nexport async function spawnAsyncModelRunner(workerSpec: { path: string } | { source: string }): Promise<ModelRunner> {\n  if (workerSpec['path']) {\n    return spawnAsyncModelRunnerWithWorker(new Worker(workerSpec['path']))\n  } else {\n    return spawnAsyncModelRunnerWithWorker(BlobWorker.fromText(workerSpec['source']))\n  }\n}\n\n/**\n * @hidden For internal use only\n */\nasync function spawnAsyncModelRunnerWithWorker(worker: Worker): Promise<ModelRunner> {\n  // Spawn the given Worker that contains the `ModelWorker`\n  const modelWorker = await spawn(worker)\n\n  // Wait for the worker to initialize the wasm model (in the worker thread)\n  const initResult = await modelWorker.initModel()\n\n  // Create a `ModelListing` instance if the listing was defined in the generated model\n  const modelListing = initResult.modelListing ? new ModelListing(initResult.modelListing) : undefined\n\n  // Maintain a `BufferedRunModelParams` instance that holds the I/O parameters\n  const params = new BufferedRunModelParams(modelListing)\n\n  // Use a flag to ensure that only one request is made at a time\n  let running = false\n\n  // Disallow `runModel` after the runner has been terminated\n  let terminated = false\n\n  return {\n    createOutputs: () => {\n      return new Outputs(initResult.outputVarIds, initResult.startTime, initResult.endTime, initResult.saveFreq)\n    },\n\n    runModel: async (inputs, outputs, options) => {\n      if (terminated) {\n        throw new Error('Async model runner has already been terminated')\n      } else if (running) {\n        throw new Error('Async model runner only supports one `runModel` call at a time')\n      } else {\n        running = true\n      }\n\n      // Update the I/O parameters\n      params.updateFromParams(inputs, outputs, options)\n\n      // Run the model in the worker. We pass the underlying `ArrayBuffer`\n      // instance back to the worker wrapped in a `Transfer` to make it\n      // no-copy transferable, and then the worker will return it back\n      // to us.\n      let ioBuffer: ArrayBuffer\n      try {\n        ioBuffer = await modelWorker.runModel(Transfer(params.getEncodedBuffer()))\n      } finally {\n        running = false\n      }\n\n      // Once the buffer is transferred to the worker, the buffer in the\n      // `BufferedRunModelParams` becomes \"detached\" and is no longer usable.\n      // After the buffer is transferred back from the worker, we need to\n      // restore the state of the object to use the new buffer.\n      params.updateFromEncodedBuffer(ioBuffer)\n\n      // Copy the output values and elapsed time from the buffer to the\n      // `Outputs` instance\n      params.finalizeOutputs(outputs)\n\n      return outputs\n    },\n\n    terminate: () => {\n      if (terminated) {\n        return Promise.resolve()\n      } else {\n        terminated = true\n        return Thread.terminate(modelWorker)\n      }\n    }\n  }\n}\n","// Copyright (c) 2020-2022 Climate Interactive / New Venture Fund\n\nimport type { TransferDescriptor } from 'threads'\nimport { expose, Transfer } from 'threads/worker'\n\nimport type { GeneratedModel, RunnableModel } from '@sdeverywhere/runtime'\nimport { BufferedRunModelParams, createRunnableModel } from '@sdeverywhere/runtime'\n\n/** @hidden */\nlet initGeneratedModel: () => Promise<GeneratedModel>\n\n/** @hidden */\nlet runnableModel: RunnableModel\n\n/**\n * Maintain a `BufferedRunModelParams` instance that wraps the transferable buffer\n * containing the I/O parameters.\n * @hidden\n */\nconst params = new BufferedRunModelParams()\n\ninterface InitResult {\n  outputVarIds: string[]\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  modelListing?: /*ModelListingSpecs*/ any\n  startTime: number\n  endTime: number\n  saveFreq: number\n  outputRowLength: number\n}\n\n/** @hidden */\nconst modelWorker = {\n  async initModel(): Promise<InitResult> {\n    if (runnableModel) {\n      throw new Error('RunnableModel was already initialized')\n    }\n\n    // Initialize the runnable model\n    const generatedModel = await initGeneratedModel()\n    runnableModel = createRunnableModel(generatedModel)\n\n    // Transfer the model metadata to the runner\n    return {\n      outputVarIds: runnableModel.outputVarIds,\n      modelListing: runnableModel.modelListing,\n      startTime: runnableModel.startTime,\n      endTime: runnableModel.endTime,\n      saveFreq: runnableModel.saveFreq,\n      outputRowLength: runnableModel.numSavePoints\n    }\n  },\n\n  runModel(ioBuffer: ArrayBuffer): TransferDescriptor<ArrayBuffer> {\n    if (!runnableModel) {\n      throw new Error('RunnableModel must be initialized before running the model in worker')\n    }\n\n    // Update the `BufferedRunModelParams` to use the values in the buffer that was transferred\n    // from the runner to the worker\n    params.updateFromEncodedBuffer(ioBuffer)\n\n    // Run the model synchronously on the worker thread using those I/O parameters\n    runnableModel.runModel(params)\n\n    // Transfer the buffer back to the runner\n    return Transfer(ioBuffer)\n  }\n}\n\n/**\n * Expose an object in the current worker thread that communicates with the\n * `ModelRunner` instance running in the main thread.  The exposed worker\n * object will take care of running the model on the worker thread and\n * sending the outputs back to the main thread.\n *\n * @param init The function that initializes the generated model instance that\n * is used in the worker thread.\n */\nexport function exposeModelWorker(init: () => Promise<GeneratedModel>): void {\n  // Save the initializer, which will be used when the runner calls `initModel`\n  // on the worker\n  initGeneratedModel = init\n\n  // Expose the worker implementation to `threads.js`\n  expose(modelWorker)\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACEA,qBAA4D;AAG5D,qBAA8D;AAkC9D,eAAsB,sBAAsB,YAAyE;AACnH,MAAI,WAAW,MAAM,GAAG;AACtB,WAAO,gCAAgC,IAAI,sBAAO,WAAW,MAAM,CAAC,CAAC;AAAA,EACvE,OAAO;AACL,WAAO,gCAAgC,0BAAW,SAAS,WAAW,QAAQ,CAAC,CAAC;AAAA,EAClF;AACF;AAKA,eAAe,gCAAgC,QAAsC;AAEnF,QAAMA,eAAc,UAAM,sBAAM,MAAM;AAGtC,QAAM,aAAa,MAAMA,aAAY,UAAU;AAG/C,QAAM,eAAe,WAAW,eAAe,IAAI,4BAAa,WAAW,YAAY,IAAI;AAG3F,QAAMC,UAAS,IAAI,sCAAuB,YAAY;AAGtD,MAAI,UAAU;AAGd,MAAI,aAAa;AAEjB,SAAO;AAAA,IACL,eAAe,MAAM;AACnB,aAAO,IAAI,uBAAQ,WAAW,cAAc,WAAW,WAAW,WAAW,SAAS,WAAW,QAAQ;AAAA,IAC3G;AAAA,IAEA,UAAU,OAAO,QAAQ,SAAS,YAAY;AAC5C,UAAI,YAAY;AACd,cAAM,IAAI,MAAM,gDAAgD;AAAA,MAClE,WAAW,SAAS;AAClB,cAAM,IAAI,MAAM,gEAAgE;AAAA,MAClF,OAAO;AACL,kBAAU;AAAA,MACZ;AAGA,MAAAA,QAAO,iBAAiB,QAAQ,SAAS,OAAO;AAMhD,UAAI;AACJ,UAAI;AACF,mBAAW,MAAMD,aAAY,aAAS,yBAASC,QAAO,iBAAiB,CAAC,CAAC;AAAA,MAC3E,UAAE;AACA,kBAAU;AAAA,MACZ;AAMA,MAAAA,QAAO,wBAAwB,QAAQ;AAIvC,MAAAA,QAAO,gBAAgB,OAAO;AAE9B,aAAO;AAAA,IACT;AAAA,IAEA,WAAW,MAAM;AACf,UAAI,YAAY;AACd,eAAO,QAAQ,QAAQ;AAAA,MACzB,OAAO;AACL,qBAAa;AACb,eAAO,sBAAO,UAAUD,YAAW;AAAA,MACrC;AAAA,IACF;AAAA,EACF;AACF;;;ACpHA,oBAAiC;AAGjC,IAAAE,kBAA4D;AAG5D,IAAI;AAGJ,IAAI;AAOJ,IAAM,SAAS,IAAI,uCAAuB;AAa1C,IAAM,cAAc;AAAA,EAClB,MAAM,YAAiC;AACrC,QAAI,eAAe;AACjB,YAAM,IAAI,MAAM,uCAAuC;AAAA,IACzD;AAGA,UAAM,iBAAiB,MAAM,mBAAmB;AAChD,wBAAgB,qCAAoB,cAAc;AAGlD,WAAO;AAAA,MACL,cAAc,cAAc;AAAA,MAC5B,cAAc,cAAc;AAAA,MAC5B,WAAW,cAAc;AAAA,MACzB,SAAS,cAAc;AAAA,MACvB,UAAU,cAAc;AAAA,MACxB,iBAAiB,cAAc;AAAA,IACjC;AAAA,EACF;AAAA,EAEA,SAAS,UAAwD;AAC/D,QAAI,CAAC,eAAe;AAClB,YAAM,IAAI,MAAM,sEAAsE;AAAA,IACxF;AAIA,WAAO,wBAAwB,QAAQ;AAGvC,kBAAc,SAAS,MAAM;AAG7B,eAAO,wBAAS,QAAQ;AAAA,EAC1B;AACF;AAWO,SAAS,kBAAkB,MAA2C;AAG3E,uBAAqB;AAGrB,4BAAO,WAAW;AACpB;","names":["modelWorker","params","import_runtime"]}