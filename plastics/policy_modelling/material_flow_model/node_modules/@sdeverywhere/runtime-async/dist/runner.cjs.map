{"version":3,"sources":["../src/runner.ts"],"sourcesContent":["// Copyright (c) 2020-2022 Climate Interactive / New Venture Fund\n\nimport { BlobWorker, spawn, Thread, Transfer, Worker } from 'threads'\n\nimport type { ModelRunner } from '@sdeverywhere/runtime'\nimport { BufferedRunModelParams, ModelListing, Outputs } from '@sdeverywhere/runtime'\n\n/**\n * Initialize a `ModelRunner` that runs the model asynchronously in a worker\n * (a Web Worker when running in a browser environment, or a worker thread\n * when running in a Node.js environment).\n *\n * In your app project, define a JavaScript file, called `worker.js` for example,\n * that initializes the generated model in the context of a worker thread:\n *\n * ```js\n * import { exposeModelWorker } from '@sdeverywhere/runtime-async/worker'\n * import loadGeneratedModel from './sde-prep/generated-model.js'\n *\n * exposeModelWorker(loadGeneratedModel)\n * ```\n *\n * Then, in your web app, call the `spawnAsyncModelRunner` function, which\n * will spawn the worker thread and initialize the `ModelRunner` that communicates\n * with the worker:\n *\n * ```js\n * import { spawnAsyncModelRunner } from '@sdeverywhere/runtime-async/runner'\n *\n * async function initApp() {\n *   // ...\n *   const runner = await spawnAsyncModelRunner({ path: './worker.js' })\n *   // ...\n * }\n * ```\n *\n * @param workerSpec Either a `path` to the worker JavaScript file, or the `source`\n * containing the full JavaScript source of the worker.\n */\nexport async function spawnAsyncModelRunner(workerSpec: { path: string } | { source: string }): Promise<ModelRunner> {\n  if (workerSpec['path']) {\n    return spawnAsyncModelRunnerWithWorker(new Worker(workerSpec['path']))\n  } else {\n    return spawnAsyncModelRunnerWithWorker(BlobWorker.fromText(workerSpec['source']))\n  }\n}\n\n/**\n * @hidden For internal use only\n */\nasync function spawnAsyncModelRunnerWithWorker(worker: Worker): Promise<ModelRunner> {\n  // Spawn the given Worker that contains the `ModelWorker`\n  const modelWorker = await spawn(worker)\n\n  // Wait for the worker to initialize the wasm model (in the worker thread)\n  const initResult = await modelWorker.initModel()\n\n  // Create a `ModelListing` instance if the listing was defined in the generated model\n  const modelListing = initResult.modelListing ? new ModelListing(initResult.modelListing) : undefined\n\n  // Maintain a `BufferedRunModelParams` instance that holds the I/O parameters\n  const params = new BufferedRunModelParams(modelListing)\n\n  // Use a flag to ensure that only one request is made at a time\n  let running = false\n\n  // Disallow `runModel` after the runner has been terminated\n  let terminated = false\n\n  return {\n    createOutputs: () => {\n      return new Outputs(initResult.outputVarIds, initResult.startTime, initResult.endTime, initResult.saveFreq)\n    },\n\n    runModel: async (inputs, outputs, options) => {\n      if (terminated) {\n        throw new Error('Async model runner has already been terminated')\n      } else if (running) {\n        throw new Error('Async model runner only supports one `runModel` call at a time')\n      } else {\n        running = true\n      }\n\n      // Update the I/O parameters\n      params.updateFromParams(inputs, outputs, options)\n\n      // Run the model in the worker. We pass the underlying `ArrayBuffer`\n      // instance back to the worker wrapped in a `Transfer` to make it\n      // no-copy transferable, and then the worker will return it back\n      // to us.\n      let ioBuffer: ArrayBuffer\n      try {\n        ioBuffer = await modelWorker.runModel(Transfer(params.getEncodedBuffer()))\n      } finally {\n        running = false\n      }\n\n      // Once the buffer is transferred to the worker, the buffer in the\n      // `BufferedRunModelParams` becomes \"detached\" and is no longer usable.\n      // After the buffer is transferred back from the worker, we need to\n      // restore the state of the object to use the new buffer.\n      params.updateFromEncodedBuffer(ioBuffer)\n\n      // Copy the output values and elapsed time from the buffer to the\n      // `Outputs` instance\n      params.finalizeOutputs(outputs)\n\n      return outputs\n    },\n\n    terminate: () => {\n      if (terminated) {\n        return Promise.resolve()\n      } else {\n        terminated = true\n        return Thread.terminate(modelWorker)\n      }\n    }\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA,qBAA4D;AAG5D,qBAA8D;AAkC9D,eAAsB,sBAAsB,YAAyE;AACnH,MAAI,WAAW,MAAM,GAAG;AACtB,WAAO,gCAAgC,IAAI,sBAAO,WAAW,MAAM,CAAC,CAAC;AAAA,EACvE,OAAO;AACL,WAAO,gCAAgC,0BAAW,SAAS,WAAW,QAAQ,CAAC,CAAC;AAAA,EAClF;AACF;AAKA,eAAe,gCAAgC,QAAsC;AAEnF,QAAM,cAAc,UAAM,sBAAM,MAAM;AAGtC,QAAM,aAAa,MAAM,YAAY,UAAU;AAG/C,QAAM,eAAe,WAAW,eAAe,IAAI,4BAAa,WAAW,YAAY,IAAI;AAG3F,QAAM,SAAS,IAAI,sCAAuB,YAAY;AAGtD,MAAI,UAAU;AAGd,MAAI,aAAa;AAEjB,SAAO;AAAA,IACL,eAAe,MAAM;AACnB,aAAO,IAAI,uBAAQ,WAAW,cAAc,WAAW,WAAW,WAAW,SAAS,WAAW,QAAQ;AAAA,IAC3G;AAAA,IAEA,UAAU,OAAO,QAAQ,SAAS,YAAY;AAC5C,UAAI,YAAY;AACd,cAAM,IAAI,MAAM,gDAAgD;AAAA,MAClE,WAAW,SAAS;AAClB,cAAM,IAAI,MAAM,gEAAgE;AAAA,MAClF,OAAO;AACL,kBAAU;AAAA,MACZ;AAGA,aAAO,iBAAiB,QAAQ,SAAS,OAAO;AAMhD,UAAI;AACJ,UAAI;AACF,mBAAW,MAAM,YAAY,aAAS,yBAAS,OAAO,iBAAiB,CAAC,CAAC;AAAA,MAC3E,UAAE;AACA,kBAAU;AAAA,MACZ;AAMA,aAAO,wBAAwB,QAAQ;AAIvC,aAAO,gBAAgB,OAAO;AAE9B,aAAO;AAAA,IACT;AAAA,IAEA,WAAW,MAAM;AACf,UAAI,YAAY;AACd,eAAO,QAAQ,QAAQ;AAAA,MACzB,OAAO;AACL,qBAAa;AACb,eAAO,sBAAO,UAAU,WAAW;AAAA,MACrC;AAAA,IACF;AAAA,EACF;AACF;","names":[]}