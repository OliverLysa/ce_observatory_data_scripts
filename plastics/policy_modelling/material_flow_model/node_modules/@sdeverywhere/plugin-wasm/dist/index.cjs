var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  wasmPlugin: () => wasmPlugin
});
module.exports = __toCommonJS(src_exports);

// src/plugin.ts
var import_fs = require("fs");
var import_promises = require("fs/promises");
var import_path = require("path");
var import_find_up = require("find-up");

// src/var-names.ts
function sdeNameForVensimName(name) {
  return "_" + name.trim().replace(/"/g, "_").replace(/\s+!$/g, "!").replace(/\s/g, "_").replace(/,/g, "_").replace(/-/g, "_").replace(/\./g, "_").replace(/\$/g, "_").replace(/'/g, "_").replace(/&/g, "_").replace(/%/g, "_").replace(/\//g, "_").replace(/\|/g, "_").toLowerCase();
}
function sdeNameForVensimVarName(varName) {
  const m = varName.match(/([^[]+)(?:\[([^\]]+)\])?/);
  if (!m) {
    throw new Error(`Invalid Vensim name: ${varName}`);
  }
  let id = sdeNameForVensimName(m[1]);
  if (m[2]) {
    const subscripts = m[2].split(",").map((x) => sdeNameForVensimName(x));
    id += `[${subscripts.join(",")}]`;
  }
  return id;
}

// src/plugin.ts
function wasmPlugin(options) {
  return new WasmPlugin(options);
}
var WasmPlugin = class {
  constructor(options) {
    this.options = options;
  }
  async preGenerate(_context, modelSpec) {
    this.outputVarIds = modelSpec.outputs.map((o) => sdeNameForVensimVarName(o.varName));
    this.bundleListing = modelSpec.bundleListing;
  }
  async postGenerateCode(context, format, content) {
    if (format !== "c") {
      throw new Error("When using plugin-wasm, you must set `genFormat` to 'c' in your `sde.config.js` file");
    }
    context.log("info", "  Generating WebAssembly module");
    const buildDir = (0, import_path.join)(context.config.prepDir, "build");
    let modelListingJs;
    if (this.bundleListing === true) {
      const modelListingPath = (0, import_path.join)(buildDir, "processed_min.json");
      const modelListingJson = await (0, import_promises.readFile)(modelListingPath, "utf8");
      const modelListingObj = JSON.parse(modelListingJson);
      modelListingJs = JSON.stringify(modelListingObj).replace(/"(\w+)"\s*:/g, "$1:");
    } else {
      modelListingJs = "undefined;";
    }
    const preJsFile = (0, import_path.join)(buildDir, "processed_extras.js");
    const preJsContent = `Module["kind"] = "wasm";
Module["outputVarIds"] = ${JSON.stringify(this.outputVarIds)};
Module["modelListing"] = ${modelListingJs}
`;
    await (0, import_promises.writeFile)(preJsFile, preJsContent);
    const stagedOutputJsFile = "generated-model.js";
    let outputJsPath;
    if (this.options?.outputJsPath) {
      outputJsPath = this.options.outputJsPath;
    } else {
      outputJsPath = (0, import_path.join)(context.config.prepDir, stagedOutputJsFile);
    }
    const outputJsDir = (0, import_path.dirname)(outputJsPath);
    const outputJsFile = (0, import_path.basename)(outputJsPath);
    const stagedOutputJsPath = context.prepareStagedFile("model", stagedOutputJsFile, outputJsDir, outputJsFile);
    await buildWasm(context, context.config.prepDir, stagedOutputJsPath, this.options);
    return content;
  }
};
async function buildWasm(context, prepDir, outputJsPath, options) {
  let emsdkDir;
  if (options?.emsdkDir) {
    if (typeof options.emsdkDir === "function") {
      emsdkDir = options.emsdkDir();
    } else {
      emsdkDir = options.emsdkDir;
    }
    if (!(0, import_fs.existsSync)(emsdkDir)) {
      throw new Error(`Invalid emsdk directory '${emsdkDir}'`);
    }
  } else {
    emsdkDir = await (0, import_find_up.findUp)("emsdk", { type: "directory" });
    if (emsdkDir === void 0) {
      throw new Error("Could not find emsdk directory");
    }
  }
  const isWin = process.platform === "win32";
  const emccCmd = isWin ? "emcc.bat" : "emcc";
  const emccCmdPath = (0, import_path.join)(emsdkDir, "upstream", "emscripten", emccCmd);
  const command = emccCmdPath;
  const args = [];
  const addArg = (arg) => {
    args.push(arg);
  };
  const addInput = (file) => {
    addArg(`build/${file}`);
  };
  const addFlag = (flag) => {
    addArg("-s");
    addArg(flag);
  };
  addInput("processed.c");
  addInput("macros.c");
  addInput("model.c");
  addInput("vensim.c");
  addArg("--pre-js");
  addArg("build/processed_extras.js");
  addArg("-Ibuild");
  addArg("-o");
  addArg(outputJsPath);
  if (options?.emccArgs !== void 0) {
    let argsArray;
    if (typeof options.emccArgs === "function") {
      argsArray = options.emccArgs();
    } else {
      argsArray = options.emccArgs;
    }
    argsArray.forEach(addArg);
  } else {
    addArg("-Wall");
    addArg("-Os");
    addFlag("STRICT=1");
    addFlag("MALLOC=emmalloc");
    addFlag("FILESYSTEM=0");
    addFlag("MODULARIZE=1");
    addFlag("SINGLE_FILE=1");
    addFlag("EXPORT_ES6=1");
    addFlag("USE_ES6_IMPORT_META=0");
    addFlag(`ENVIRONMENT='web,webview,worker'`);
    addFlag(
      `EXPORTED_FUNCTIONS=['_malloc','_free','_getInitialTime','_getFinalTime','_getSaveper','_setLookup','_runModelWithBuffers']`
    );
    addFlag(`EXPORTED_RUNTIME_METHODS=['cwrap']`);
  }
  const emccOutput = await context.spawnChild(prepDir, command, args, {
    // Ignore unhelpful Emscripten SDK cache messages
    ignoredMessageFilter: "cache:INFO",
    // The default error message from `spawnChild` is not very informative, so the
    // following allows us to throw our own error
    ignoreError: true
  });
  if (emccOutput.exitCode !== 0) {
    throw new Error(`Failed to compile C model to WebAssembly: emcc command failed (code=${emccOutput.exitCode})`);
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  wasmPlugin
});
//# sourceMappingURL=index.cjs.map