{"version":3,"sources":["../src/plugin.ts","../src/var-names.ts"],"sourcesContent":["// Copyright (c) 2022 Climate Interactive / New Venture Fund\n\nimport { existsSync } from 'fs'\nimport { readFile, writeFile } from 'fs/promises'\n\nimport { basename, dirname, join as joinPath } from 'path'\n\nimport { findUp } from 'find-up'\n\nimport type { BuildContext, ResolvedModelSpec, Plugin } from '@sdeverywhere/build'\n\nimport type { WasmPluginOptions } from './options'\nimport { sdeNameForVensimVarName } from './var-names'\n\nexport function wasmPlugin(options?: WasmPluginOptions): Plugin {\n  return new WasmPlugin(options)\n}\n\nclass WasmPlugin implements Plugin {\n  // The properties from `modelSpec` captured in `preGenerate`\n  private outputVarIds: string[]\n  private bundleListing: boolean\n\n  constructor(private readonly options?: WasmPluginOptions) {}\n\n  async preGenerate(_context: BuildContext, modelSpec: ResolvedModelSpec): Promise<void> {\n    // Save some properties for later processing.  This is a workaround for the fact\n    // that `modelSpec` is not passed to `postGenerateCode`, so we need to capture\n    // these values here.\n    this.outputVarIds = modelSpec.outputs.map(o => sdeNameForVensimVarName(o.varName))\n    this.bundleListing = modelSpec.bundleListing\n  }\n\n  async postGenerateCode(context: BuildContext, format: 'js' | 'c', content: string): Promise<string> {\n    if (format !== 'c') {\n      throw new Error(\"When using plugin-wasm, you must set `genFormat` to 'c' in your `sde.config.js` file\")\n    }\n\n    context.log('info', '  Generating WebAssembly module')\n\n    const buildDir = joinPath(context.config.prepDir, 'build')\n    let modelListingJs: string\n    if (this.bundleListing === true) {\n      // Include the minimal model listing\n      const modelListingPath = joinPath(buildDir, 'processed_min.json')\n      const modelListingJson = await readFile(modelListingPath, 'utf8')\n      const modelListingObj = JSON.parse(modelListingJson)\n      modelListingJs = JSON.stringify(modelListingObj).replace(/\"(\\w+)\"\\s*:/g, '$1:')\n    } else {\n      // Omit the minimal model listing\n      modelListingJs = 'undefined;'\n    }\n\n    // Write a file that will be folded into the generated Wasm module\n    const preJsFile = joinPath(buildDir, 'processed_extras.js')\n    const preJsContent = `\\\nModule[\"kind\"] = \"wasm\";\nModule[\"outputVarIds\"] = ${JSON.stringify(this.outputVarIds)};\nModule[\"modelListing\"] = ${modelListingJs}\n`\n    await writeFile(preJsFile, preJsContent)\n\n    // If `outputJsPath` is undefined, write `generated-model.js` to the prep dir\n    const stagedOutputJsFile = 'generated-model.js'\n    let outputJsPath: string\n    if (this.options?.outputJsPath) {\n      outputJsPath = this.options.outputJsPath\n    } else {\n      outputJsPath = joinPath(context.config.prepDir, stagedOutputJsFile)\n    }\n    const outputJsDir = dirname(outputJsPath)\n    const outputJsFile = basename(outputJsPath)\n\n    // Ensure that the staged directory exists before we build the Wasm model\n    // (otherwise emcc will fail) and add a staged file entry\n    const stagedOutputJsPath = context.prepareStagedFile('model', stagedOutputJsFile, outputJsDir, outputJsFile)\n\n    // Generate the Wasm binary (wrapped in a JS file)\n    await buildWasm(context, context.config.prepDir, stagedOutputJsPath, this.options)\n\n    // context.log('info', '  Done!')\n\n    return content\n  }\n}\n\n/**\n * Generate a JS file (containing an embedded Wasm blob) from the C file.\n */\nasync function buildWasm(\n  context: BuildContext,\n  prepDir: string,\n  outputJsPath: string,\n  options?: WasmPluginOptions\n): Promise<void> {\n  // Locate the Emscripten SDK directory\n  let emsdkDir: string\n  if (options?.emsdkDir) {\n    // Try the configured directory\n    if (typeof options.emsdkDir === 'function') {\n      emsdkDir = options.emsdkDir()\n    } else {\n      emsdkDir = options.emsdkDir\n    }\n    if (!existsSync(emsdkDir)) {\n      throw new Error(`Invalid emsdk directory '${emsdkDir}'`)\n    }\n  } else {\n    // Walk up the directory structure to find the nearest `emsdk` directory\n    emsdkDir = await findUp('emsdk', { type: 'directory' })\n    if (emsdkDir === undefined) {\n      throw new Error('Could not find emsdk directory')\n    }\n  }\n\n  // XXX: On Windows, we need to use Windows-specific commands; need to revisit\n  const isWin = process.platform === 'win32'\n  const emccCmd = isWin ? 'emcc.bat' : 'emcc'\n  const emccCmdPath = joinPath(emsdkDir, 'upstream', 'emscripten', emccCmd)\n\n  // Use Emscripten to compile the C model into a Wasm blob packaged inside\n  // an ES6 module.  We use `SINGLE_FILE=1` to include the Wasm directly\n  // inside the JS file as a base64-encoded string.  This increases the\n  // total file size by about 30%, but having it bundled makes building\n  // easier and improves startup time (we don't have make a separate fetch\n  // to load it over the network).\n  const command = emccCmdPath\n  const args: string[] = []\n  const addArg = (arg: string) => {\n    args.push(arg)\n  }\n  const addInput = (file: string) => {\n    addArg(`build/${file}`)\n  }\n  const addFlag = (flag: string) => {\n    addArg('-s')\n    addArg(flag)\n  }\n  addInput('processed.c')\n  addInput('macros.c')\n  addInput('model.c')\n  addInput('vensim.c')\n  addArg('--pre-js')\n  addArg('build/processed_extras.js')\n  addArg('-Ibuild')\n  addArg('-o')\n  addArg(outputJsPath)\n  if (options?.emccArgs !== undefined) {\n    let argsArray: string[]\n    if (typeof options.emccArgs === 'function') {\n      argsArray = options.emccArgs()\n    } else {\n      argsArray = options.emccArgs\n    }\n    argsArray.forEach(addArg)\n  } else {\n    addArg('-Wall')\n    addArg('-Os')\n    addFlag('STRICT=1')\n    addFlag('MALLOC=emmalloc')\n    addFlag('FILESYSTEM=0')\n    addFlag('MODULARIZE=1')\n    addFlag('SINGLE_FILE=1')\n    addFlag('EXPORT_ES6=1')\n    addFlag('USE_ES6_IMPORT_META=0')\n    // Note: The following argument is used to override the default list of supported environments.\n    // The problem is that the default list includes \"node\", but we can't use `USE_ES6_IMPORT_META=0`\n    // if \"node\" is included in the list.  We want `USE_ES6_IMPORT_META=0` because using 1 causes\n    // problems with our init code since we also use `SINGLE_FILE=1` (inlined wasm).  The bottom\n    // line is that if we omit \"node\" from this list, the wasm will still work fine in both browser\n    // and Node.js contexts (tested in Emscripten 2.0.34 and 3.1.46).\n    addFlag(`ENVIRONMENT='web,webview,worker'`)\n    addFlag(\n      `EXPORTED_FUNCTIONS=['_malloc','_free','_getInitialTime','_getFinalTime','_getSaveper','_setLookup','_runModelWithBuffers']`\n    )\n    addFlag(`EXPORTED_RUNTIME_METHODS=['cwrap']`)\n  }\n\n  // context.log('verbose', `    emcc args: ${args}`)\n\n  const emccOutput = await context.spawnChild(prepDir, command, args, {\n    // Ignore unhelpful Emscripten SDK cache messages\n    ignoredMessageFilter: 'cache:INFO',\n    // The default error message from `spawnChild` is not very informative, so the\n    // following allows us to throw our own error\n    ignoreError: true\n  })\n  if (emccOutput.exitCode !== 0) {\n    throw new Error(`Failed to compile C model to WebAssembly: emcc command failed (code=${emccOutput.exitCode})`)\n  }\n}\n","// Copyright (c) 2024 Climate Interactive / New Venture Fund\n\n/**\n * Helper function that converts a Vensim variable or subscript name\n * into a valid C identifier as used by SDE.\n * TODO: Import helper function from `compile` package instead\n */\nfunction sdeNameForVensimName(name: string): string {\n  return (\n    '_' +\n    name\n      .trim()\n      .replace(/\"/g, '_')\n      .replace(/\\s+!$/g, '!')\n      .replace(/\\s/g, '_')\n      .replace(/,/g, '_')\n      .replace(/-/g, '_')\n      .replace(/\\./g, '_')\n      .replace(/\\$/g, '_')\n      .replace(/'/g, '_')\n      .replace(/&/g, '_')\n      .replace(/%/g, '_')\n      .replace(/\\//g, '_')\n      .replace(/\\|/g, '_')\n      .toLowerCase()\n  )\n}\n\n/**\n * Helper function that converts a Vensim variable name (possibly containing\n * subscripts) into a valid C identifier as used by SDE.\n * TODO: Import helper function from `compile` package instead\n */\nexport function sdeNameForVensimVarName(varName: string): string {\n  const m = varName.match(/([^[]+)(?:\\[([^\\]]+)\\])?/)\n  if (!m) {\n    throw new Error(`Invalid Vensim name: ${varName}`)\n  }\n  let id = sdeNameForVensimName(m[1])\n  if (m[2]) {\n    const subscripts = m[2].split(',').map(x => sdeNameForVensimName(x))\n    id += `[${subscripts.join(',')}]`\n  }\n\n  return id\n}\n"],"mappings":"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","names":[]}