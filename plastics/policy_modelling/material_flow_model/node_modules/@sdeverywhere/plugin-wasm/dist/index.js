// src/plugin.ts
import { existsSync } from "fs";
import { readFile, writeFile } from "fs/promises";
import { basename, dirname, join as joinPath } from "path";
import { findUp } from "find-up";

// src/var-names.ts
function sdeNameForVensimName(name) {
  return "_" + name.trim().replace(/"/g, "_").replace(/\s+!$/g, "!").replace(/\s/g, "_").replace(/,/g, "_").replace(/-/g, "_").replace(/\./g, "_").replace(/\$/g, "_").replace(/'/g, "_").replace(/&/g, "_").replace(/%/g, "_").replace(/\//g, "_").replace(/\|/g, "_").toLowerCase();
}
function sdeNameForVensimVarName(varName) {
  const m = varName.match(/([^[]+)(?:\[([^\]]+)\])?/);
  if (!m) {
    throw new Error(`Invalid Vensim name: ${varName}`);
  }
  let id = sdeNameForVensimName(m[1]);
  if (m[2]) {
    const subscripts = m[2].split(",").map((x) => sdeNameForVensimName(x));
    id += `[${subscripts.join(",")}]`;
  }
  return id;
}

// src/plugin.ts
function wasmPlugin(options) {
  return new WasmPlugin(options);
}
var WasmPlugin = class {
  constructor(options) {
    this.options = options;
  }
  async preGenerate(_context, modelSpec) {
    this.outputVarIds = modelSpec.outputs.map((o) => sdeNameForVensimVarName(o.varName));
    this.bundleListing = modelSpec.bundleListing;
  }
  async postGenerateCode(context, format, content) {
    if (format !== "c") {
      throw new Error("When using plugin-wasm, you must set `genFormat` to 'c' in your `sde.config.js` file");
    }
    context.log("info", "  Generating WebAssembly module");
    const buildDir = joinPath(context.config.prepDir, "build");
    let modelListingJs;
    if (this.bundleListing === true) {
      const modelListingPath = joinPath(buildDir, "processed_min.json");
      const modelListingJson = await readFile(modelListingPath, "utf8");
      const modelListingObj = JSON.parse(modelListingJson);
      modelListingJs = JSON.stringify(modelListingObj).replace(/"(\w+)"\s*:/g, "$1:");
    } else {
      modelListingJs = "undefined;";
    }
    const preJsFile = joinPath(buildDir, "processed_extras.js");
    const preJsContent = `Module["kind"] = "wasm";
Module["outputVarIds"] = ${JSON.stringify(this.outputVarIds)};
Module["modelListing"] = ${modelListingJs}
`;
    await writeFile(preJsFile, preJsContent);
    const stagedOutputJsFile = "generated-model.js";
    let outputJsPath;
    if (this.options?.outputJsPath) {
      outputJsPath = this.options.outputJsPath;
    } else {
      outputJsPath = joinPath(context.config.prepDir, stagedOutputJsFile);
    }
    const outputJsDir = dirname(outputJsPath);
    const outputJsFile = basename(outputJsPath);
    const stagedOutputJsPath = context.prepareStagedFile("model", stagedOutputJsFile, outputJsDir, outputJsFile);
    await buildWasm(context, context.config.prepDir, stagedOutputJsPath, this.options);
    return content;
  }
};
async function buildWasm(context, prepDir, outputJsPath, options) {
  let emsdkDir;
  if (options?.emsdkDir) {
    if (typeof options.emsdkDir === "function") {
      emsdkDir = options.emsdkDir();
    } else {
      emsdkDir = options.emsdkDir;
    }
    if (!existsSync(emsdkDir)) {
      throw new Error(`Invalid emsdk directory '${emsdkDir}'`);
    }
  } else {
    emsdkDir = await findUp("emsdk", { type: "directory" });
    if (emsdkDir === void 0) {
      throw new Error("Could not find emsdk directory");
    }
  }
  const isWin = process.platform === "win32";
  const emccCmd = isWin ? "emcc.bat" : "emcc";
  const emccCmdPath = joinPath(emsdkDir, "upstream", "emscripten", emccCmd);
  const command = emccCmdPath;
  const args = [];
  const addArg = (arg) => {
    args.push(arg);
  };
  const addInput = (file) => {
    addArg(`build/${file}`);
  };
  const addFlag = (flag) => {
    addArg("-s");
    addArg(flag);
  };
  addInput("processed.c");
  addInput("macros.c");
  addInput("model.c");
  addInput("vensim.c");
  addArg("--pre-js");
  addArg("build/processed_extras.js");
  addArg("-Ibuild");
  addArg("-o");
  addArg(outputJsPath);
  if (options?.emccArgs !== void 0) {
    let argsArray;
    if (typeof options.emccArgs === "function") {
      argsArray = options.emccArgs();
    } else {
      argsArray = options.emccArgs;
    }
    argsArray.forEach(addArg);
  } else {
    addArg("-Wall");
    addArg("-Os");
    addFlag("STRICT=1");
    addFlag("MALLOC=emmalloc");
    addFlag("FILESYSTEM=0");
    addFlag("MODULARIZE=1");
    addFlag("SINGLE_FILE=1");
    addFlag("EXPORT_ES6=1");
    addFlag("USE_ES6_IMPORT_META=0");
    addFlag(`ENVIRONMENT='web,webview,worker'`);
    addFlag(
      `EXPORTED_FUNCTIONS=['_malloc','_free','_getInitialTime','_getFinalTime','_getSaveper','_setLookup','_runModelWithBuffers']`
    );
    addFlag(`EXPORTED_RUNTIME_METHODS=['cwrap']`);
  }
  const emccOutput = await context.spawnChild(prepDir, command, args, {
    // Ignore unhelpful Emscripten SDK cache messages
    ignoredMessageFilter: "cache:INFO",
    // The default error message from `spawnChild` is not very informative, so the
    // following allows us to throw our own error
    ignoreError: true
  });
  if (emccOutput.exitCode !== 0) {
    throw new Error(`Failed to compile C model to WebAssembly: emcc command failed (code=${emccOutput.exitCode})`);
  }
}
export {
  wasmPlugin
};
//# sourceMappingURL=index.js.map