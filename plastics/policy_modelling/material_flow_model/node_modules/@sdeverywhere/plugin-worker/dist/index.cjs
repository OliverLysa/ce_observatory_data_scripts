var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  workerPlugin: () => workerPlugin
});
module.exports = __toCommonJS(src_exports);

// ../../node_modules/.pnpm/tsup@8.2.4_typescript@5.2.2/node_modules/tsup/assets/cjs_shims.js
var getImportMetaUrl = () => typeof document === "undefined" ? new URL(`file:${__filename}`).href : document.currentScript && document.currentScript.src || new URL("main.js", document.baseURI).href;
var importMetaUrl = /* @__PURE__ */ getImportMetaUrl();

// src/plugin.ts
var import_path2 = require("path");
var import_vite = require("vite");

// src/vite-config.ts
var import_path = require("path");
var import_url = require("url");
var __filename2 = (0, import_url.fileURLToPath)(importMetaUrl);
var __dirname = (0, import_path.dirname)(__filename2);
function createViteConfig(stagedModelDir, modelJsFile, outputFile) {
  const root = stagedModelDir;
  const entry = (0, import_path.resolve)(__dirname, "..", "template-worker", "worker.js");
  return {
    // Don't use an external config file
    configFile: false,
    // Use the root directory configured above
    root,
    // Don't clear the screen in dev mode so that we can see builder output
    clearScreen: false,
    // Disable vite output by default
    // TODO: Re-enable logging if `--verbose` option is used?
    logLevel: "silent",
    // Configure path aliases
    resolve: {
      alias: [
        // In the template, we use `@_generatedModelFile_` as an alias for the model
        // file containing the generated JS or Wasm model
        {
          find: "@_generatedModelFile_",
          replacement: (0, import_path.resolve)(stagedModelDir, modelJsFile)
        }
      ],
      // XXX: Prevent Vite from using the `browser` section of `threads/package.json`
      // since we want to force the use of the general module (under dist) that chooses
      // the correct implementation (Web Worker vs worker_threads) at runtime.  This
      // gets the job done, but is fragile because it applies to all dependencies even
      // though we really only need this workaround for the threads package.  Fortunately
      // the worker template is very simple (only depends on `@sdeverywhere/runtime-async`,
      // which in turn only depends on `@sdeverywhere/runtime` and `threads`, so we should
      // be safe to use this workaround for a while.  Note that the default value of this
      // property is `['browser', 'module', 'jsnext:main', 'jsnext']`, so we override it
      // to omit the 'browser' item.
      mainFields: ["module", "jsnext:main", "jsnext"]
    },
    build: {
      // Write output file to the `staged/model` directory; note that this path is
      // relative to the bundle `root` directory
      outDir: ".",
      emptyOutDir: false,
      lib: {
        entry,
        name: "worker",
        formats: ["iife"],
        fileName: () => outputFile
      },
      rollupOptions: {
        onwarn: (warning, warn) => {
          if (warning.code !== "EVAL") {
            warn(warning);
          }
        }
      }
    }
  };
}

// src/plugin.ts
function workerPlugin(options) {
  return new WorkerPlugin(options);
}
var WorkerPlugin = class {
  constructor(options) {
    this.options = options;
  }
  async postGenerate(context) {
    const log = context.log;
    log("info", "Building worker");
    const prepDir = context.config.prepDir;
    const srcDir = "model";
    const stagedModelDir = (0, import_path2.join)(prepDir, "staged", srcDir);
    const inModelJsFile = "generated-model.js";
    const outWorkerJsFile = "worker.js";
    const outputPaths = this.options?.outputPaths || [(0, import_path2.join)(prepDir, outWorkerJsFile)];
    for (const outputPath of outputPaths) {
      const dstDir = (0, import_path2.dirname)(outputPath);
      const dstFile = (0, import_path2.basename)(outputPath);
      context.prepareStagedFile(srcDir, outWorkerJsFile, dstDir, dstFile);
    }
    const viteConfig = createViteConfig(stagedModelDir, inModelJsFile, outWorkerJsFile);
    await (0, import_vite.build)(viteConfig);
    return true;
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  workerPlugin
});
//# sourceMappingURL=index.cjs.map