// src/plugin.ts
import { basename, dirname as dirname2, join as joinPath } from "path";
import { build } from "vite";

// src/vite-config.ts
import { dirname, resolve as resolvePath } from "path";
import { fileURLToPath } from "url";
var __filename = fileURLToPath(import.meta.url);
var __dirname = dirname(__filename);
function createViteConfig(stagedModelDir, modelJsFile, outputFile) {
  const root = stagedModelDir;
  const entry = resolvePath(__dirname, "..", "template-worker", "worker.js");
  return {
    // Don't use an external config file
    configFile: false,
    // Use the root directory configured above
    root,
    // Don't clear the screen in dev mode so that we can see builder output
    clearScreen: false,
    // Disable vite output by default
    // TODO: Re-enable logging if `--verbose` option is used?
    logLevel: "silent",
    // Configure path aliases
    resolve: {
      alias: [
        // In the template, we use `@_generatedModelFile_` as an alias for the model
        // file containing the generated JS or Wasm model
        {
          find: "@_generatedModelFile_",
          replacement: resolvePath(stagedModelDir, modelJsFile)
        }
      ],
      // XXX: Prevent Vite from using the `browser` section of `threads/package.json`
      // since we want to force the use of the general module (under dist) that chooses
      // the correct implementation (Web Worker vs worker_threads) at runtime.  This
      // gets the job done, but is fragile because it applies to all dependencies even
      // though we really only need this workaround for the threads package.  Fortunately
      // the worker template is very simple (only depends on `@sdeverywhere/runtime-async`,
      // which in turn only depends on `@sdeverywhere/runtime` and `threads`, so we should
      // be safe to use this workaround for a while.  Note that the default value of this
      // property is `['browser', 'module', 'jsnext:main', 'jsnext']`, so we override it
      // to omit the 'browser' item.
      mainFields: ["module", "jsnext:main", "jsnext"]
    },
    build: {
      // Write output file to the `staged/model` directory; note that this path is
      // relative to the bundle `root` directory
      outDir: ".",
      emptyOutDir: false,
      lib: {
        entry,
        name: "worker",
        formats: ["iife"],
        fileName: () => outputFile
      },
      rollupOptions: {
        onwarn: (warning, warn) => {
          if (warning.code !== "EVAL") {
            warn(warning);
          }
        }
      }
    }
  };
}

// src/plugin.ts
function workerPlugin(options) {
  return new WorkerPlugin(options);
}
var WorkerPlugin = class {
  constructor(options) {
    this.options = options;
  }
  async postGenerate(context) {
    const log = context.log;
    log("info", "Building worker");
    const prepDir = context.config.prepDir;
    const srcDir = "model";
    const stagedModelDir = joinPath(prepDir, "staged", srcDir);
    const inModelJsFile = "generated-model.js";
    const outWorkerJsFile = "worker.js";
    const outputPaths = this.options?.outputPaths || [joinPath(prepDir, outWorkerJsFile)];
    for (const outputPath of outputPaths) {
      const dstDir = dirname2(outputPath);
      const dstFile = basename(outputPath);
      context.prepareStagedFile(srcDir, outWorkerJsFile, dstDir, dstFile);
    }
    const viteConfig = createViteConfig(stagedModelDir, inModelJsFile, outWorkerJsFile);
    await build(viteConfig);
    return true;
  }
};
export {
  workerPlugin
};
//# sourceMappingURL=index.js.map