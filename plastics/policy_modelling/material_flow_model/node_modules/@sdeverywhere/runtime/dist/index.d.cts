import { Result } from 'neverthrow';

/** A variable name, as used in the modeling tool. */
type VarName = string;
/** A variable identifier, as used in model code generated by SDEverywhere. */
type VarId = string;
/** An input variable identifier, as used in model code generated by SDEverywhere. */
type InputVarId = string;
/** An output variable identifier, as used in model code generated by SDEverywhere. */
type OutputVarId = string;
/**
 * The variable index metadata that is used to identify a specific instance of a
 * variable in a generated model.
 *
 * @hidden This is not yet part of the public API.
 */
interface VarSpec {
    /** The variable index as used in the generated C/JS code. */
    varIndex: number;
    /** The subscript index values as used in the generated C/JS code. */
    subscriptIndices?: number[] | Int32Array;
}
/**
 * A reference to a variable in the generated model.  A variable can be identified
 * using either a `VarName` (the variable name, as used in the modeling tool) or a
 * `VarId` (the variable identifier, as used in model code generated by SDEverywhere).
 */
interface VarRef {
    /**
     * The name of the variable, as used in the modeling tool.  If defined, the implementation
     * will use this to identify the variable, and will ignore the `varId` property.
     */
    varName?: VarName;
    /**
     * The identifier of the variable, as used in model code generated by SDEverywhere.  If
     * defined, the implementation will use this to identify the variable, and will ignore
     * the `varName` property.
     */
    varId?: VarId;
    /**
     * The low-level spec for the variable to be modified.  If defined, the implementation
     * will use this identify the variable.  If it is undefined, the implementation will
     * use the `varId` or `varName` to identify the variable, and may use this property
     * to cache the resulting `VarSpec` in this property for performance reasons.
     *
     * @hidden This is not yet part of the public API.
     */
    varSpec?: VarSpec;
}
/** A data point. */
interface Point {
    /** The x value (typically a time value). */
    x: number;
    /** The y value. */
    y: number;
}

/** Callback functions that are called when the input value is changed. */
interface InputCallbacks {
    /** Called after a new value is set. */
    onSet?: () => void;
}
/**
 * Represents a writable model input.
 */
interface InputValue {
    /** The ID of the associated input variable, as used in SDEverywhere. */
    varId: InputVarId;
    /** Get the current value of the input. */
    get: () => number;
    /** Set the input to the given value. */
    set: (value: number) => void;
    /** Reset the input to its default value. */
    reset: () => void;
    /** Callback functions that are called when the input value is changed. */
    callbacks: InputCallbacks;
}
/**
 * Create a basic `InputValue` instance that notifies when a new value is set.
 *
 * @param varId The input variable ID, as used in SDEverywhere.
 * @param defaultValue The default value of the input.
 * @param initialValue The inital value of the input; if undefined, will use `defaultValue`.
 */
declare function createInputValue(varId: InputVarId, defaultValue: number, initialValue?: number): InputValue;

/** Indicates the type of error encountered when parsing an outputs buffer. */
type ParseError = 'invalid-point-count';
/**
 * A time series of data points for an output variable.
 */
declare class Series {
    readonly varId: OutputVarId;
    readonly points: Point[];
    /**
     * @param varId The ID for the output variable (as used by SDEverywhere).
     * @param points The data points for the variable, one point per time increment.
     */
    constructor(varId: OutputVarId, points: Point[]);
    /**
     * Return the Y value at the given time.  Note that this does not attempt to interpolate
     * if there is no data point defined for the given time and will return undefined in
     * that case.
     *
     * @param time The x (time) value.
     * @return The y value for the given time, or undefined if there is no data point defined
     * for the given time.
     */
    getValueAtTime(time: number): number | undefined;
    /**
     * Create a new `Series` instance that is a copy of this one.
     */
    copy(): Series;
}
/** Represents the outputs from a model run. */
declare class Outputs {
    readonly varIds: OutputVarId[];
    readonly startTime: number;
    readonly endTime: number;
    readonly saveFreq: number;
    /** The number of data points in each series. */
    readonly seriesLength: number;
    /** The array of series, one for each output variable. */
    readonly varSeries: Series[];
    /**
     * The latest model run time, in milliseconds.
     * @hidden This is not yet part of the public API; it is exposed here for use
     * in performance testing tools.
     */
    runTimeInMillis: number;
    /**
     * The optional set of specs that dictate which variables from the model will be
     * stored in this `Outputs` instance.  If undefined, the default set of outputs
     * will be stored (as configured in `varIds`).
     * @hidden This is not yet part of the public API; it is exposed here for use
     * in experimental testing tools.
     */
    varSpecs?: VarSpec[];
    /**
     * @param varIds The output variable identifiers.
     * @param startTime The start time for the model.
     * @param endTime The end time for the model.
     * @param saveFreq The frequency with which output values are saved (aka `SAVEPER`).
     */
    constructor(varIds: OutputVarId[], startTime: number, endTime: number, saveFreq?: number);
    /**
     * The optional set of specs that dictate which variables from the model will be
     * stored in this `Outputs` instance.  If undefined, the default set of outputs
     * will be stored (as configured in `varIds`).
     * @hidden This is not yet part of the public API; it is exposed here for use
     * in experimental testing tools.
     */
    setVarSpecs(varSpecs: VarSpec[]): void;
    /**
     * Parse the given raw float buffer (produced by the model) and store the values
     * into this `Outputs` instance.
     *
     * Note that the length of `outputsBuffer` must be greater than or equal to
     * the capacity of this `Outputs` instance.  The `Outputs` instance is allowed
     * to be smaller to support the case where you want to extract a subset of
     * the time range in the buffer produced by the model.
     *
     * @param outputsBuffer The raw outputs buffer produced by the model.
     * @param rowLength The number of elements per row (one element per save point).
     * @return An `ok` result if the buffer is valid, otherwise an `err` result.
     */
    updateFromBuffer(outputsBuffer: Float64Array, rowLength: number): Result<void, ParseError>;
    /**
     * Return the series for the given output variable.
     *
     * @param varId The ID of the output variable (as used by SDEverywhere).
     */
    getSeriesForVar(varId: OutputVarId): Series | undefined;
}

/**
 * Specifies the data that will be used to set or override a lookup definition.
 */
interface LookupDef {
    /** The reference that identifies the lookup or data variable to be modified. */
    varRef: VarRef;
    /** The lookup data as a flat array of (x,y) pairs. */
    points: Float64Array;
}
/**
 * Create a `LookupDef` instance from the given array of `Point` objects.
 *
 * @param varRef The reference to the lookup or data variable to be modified.
 * @param points The lookup data as an array of `Point` objects.
 */
declare function createLookupDef(varRef: VarRef, points: Point[]): LookupDef;

/**
 * Return the length of the array that is required to store the variable
 * indices for the given `VarSpec` instances.
 *
 * @hidden This is not part of the public API; it is exposed here for use by
 * the synchronous and asynchronous model runner implementations.
 *
 * @param varSpecs The `VarSpec` instances to encode.
 */
declare function getEncodedVarIndicesLength(varSpecs: VarSpec[]): number;
/**
 * Encode variable indices to the given array.
 *
 * @hidden This is not part of the public API; it is exposed here for use by
 * the synchronous and asynchronous model runner implementations.
 *
 * @param varSpecs The `VarSpec` instances to encode.
 */
declare function encodeVarIndices(varSpecs: VarSpec[], indicesArray: Int32Array): void;
/**
 * Return the lengths of the arrays that are required to store the lookup data
 * and indices for the given `LookupDef` instances.
 *
 * @hidden This is not part of the public API; it is exposed here for use by
 * the synchronous and asynchronous model runner implementations.
 *
 * @param lookupDefs The `LookupDef` instances to encode.
 */
declare function getEncodedLookupBufferLengths(lookupDefs: LookupDef[]): {
    lookupIndicesLength: number;
    lookupsLength: number;
};
/**
 * Encode lookup data and indices to the given arrays.
 *
 * @hidden This is not part of the public API; it is exposed here for use by
 * the synchronous and asynchronous model runner implementations.
 *
 * @param lookupDefs The `LookupDef` instances to encode.
 * @param lookupIndicesArray The view on the lookup indices buffer.
 * @param lookupsArray The view on the lookup data buffer.  This can be undefined in
 * the case where the data for the lookup(s) is empty.
 */
declare function encodeLookups(lookupDefs: LookupDef[], lookupIndicesArray: Int32Array, lookupsArray: Float64Array | undefined): void;
/**
 * Decode lookup data and indices from the given buffer views and return the
 * reconstructed `LookupDef` instances.
 *
 * @hidden This is not part of the public API; it is exposed here for use by
 * the synchronous and asynchronous model runner implementations.
 *
 * @param lookupIndicesArray The view on the lookup indices buffer.
 * @param lookupsArray The view on the lookup data buffer.  This can be undefined in
 * the case where the data for the lookup(s) is empty.
 */
declare function decodeLookups(lookupIndicesArray: Int32Array, lookupsArray: Float64Array | undefined): LookupDef[];

type SubscriptId = string;
type DimensionId = string;
/**
 * This matches the shape of the minimal model `listing_min.json` that is generated
 * by the `sde generate --list` command.
 *
 * @hidden This is not yet part of the public API; it is exposed here for
 * internal use only.
 */
interface ModelListingSpecs {
    dimensions: {
        id: DimensionId;
        subIds: SubscriptId[];
    }[];
    variables: {
        id: VarId;
        index: number;
        dimIds?: DimensionId[];
    }[];
}
/**
 * @hidden This is not yet part of the public API; it is exposed here for use
 * in experimental testing tools.
 */
declare class ModelListing {
    readonly varSpecs: Map<VarId, VarSpec>;
    constructor(listingObj: ModelListingSpecs);
    /**
     * Return the `VarSpec` for the given variable ID, or undefined if there is no spec defined
     * in the listing for that variable.
     */
    getSpecForVarId(varId: VarId): VarSpec | undefined;
    /**
     * Return the `VarSpec` for the given variable name, or undefined if there is no spec defined
     * in the listing for that variable.
     */
    getSpecForVarName(varName: VarName): VarSpec | undefined;
    /**
     * Create a new `Outputs` instance that uses the same start/end years as the given "normal"
     * `Outputs` instance but is prepared for reading the specified internal variables from the model.
     *
     * @param normalOutputs The `Outputs` that is used to access normal output variables from the model.
     * @param varIds The variable IDs to include with the new `Outputs` instance.
     */
    deriveOutputs(normalOutputs: Outputs, varIds: OutputVarId[]): Outputs;
}

/**
 * Additional options that can be passed to a `runModel` call to influence the model run.
 */
interface RunModelOptions {
    /**
     * If defined, override the data for the specified lookups and/or data variables.
     *
     * If data was already defined in the generated model, the data provided in a
     * `LookupDef` here will override the default data in the generated model.
     *
     * Note that unlike the `inputs` parameter for `runModel` (which must be provided
     * with each call), the data overrides provided here persist after the `runModel`
     * call.  If you pass `lookups` in your Nth `runModel` call, that lookup data will
     * still be in effect for the (N+1)th call.  In other words, if your lookup data
     * is not changing, you do not need to supply it with every `runModel` call.
     */
    lookups?: LookupDef[];
}

/**
 * Encapsulates the parameters that are passed to a `runModel` call.
 *
 * @hidden This is not yet exposed in the public API; it is currently only used by
 * the implementations of the `RunnableModel` interface.
 */
interface RunModelParams {
    /**
     * Return the array containing the inputs, or undefined if the implementation does not
     * have the inputs readily available in an array.  If this returns undefined, use
     * `copyInputs` to copy the inputs into a provided array.
     */
    getInputs(): Float64Array | undefined;
    /**
     * Copy the input values into an array.
     *
     * @param array An existing array, or undefined.  If `array` is undefined, or it is
     * not large enough to hold the input values, the `create` function will be called
     * to allocate a new array.
     * @param create A function that allocates a new `Float64Array` with the given length.
     */
    copyInputs(array: Float64Array | undefined, create: (numElements: number) => Float64Array): void;
    /**
     * Return the length (in elements) of the output indices array, or 0 if the indices are
     * not active (i.e., if they were not included in the latest `runModel` call).
     */
    getOutputIndicesLength(): number;
    /**
     * Return the array containing the output indices, or undefined if the implementation does not
     * have the output indices readily available in an array.  If this returns undefined, use
     * `copyOutputIndices` to copy the output indices into a provided array.
     */
    getOutputIndices(): Int32Array | undefined;
    /**
     * Copy the output indices into an array.
     *
     * @param array An existing array, or undefined.  If `array` is undefined, or it is
     * not large enough to hold the input values, the `create` function will be called
     * to allocate a new array.
     * @param create A function that allocates a new `Int32Array` with the given length.
     */
    copyOutputIndices(array: Int32Array | undefined, create: (numElements: number) => Int32Array): void;
    /**
     * Return the length (in elements) of the array that will receive the outputs.
     */
    getOutputsLength(): number;
    /**
     * Return the array containing the outputs, or undefined if the implementation does not
     * have an array available for writing the outputs.
     */
    getOutputs(): Float64Array | undefined;
    /**
     * Return the `Outputs` object, or undefined if the implementation does not keep a reference
     * to the `Outputs` object that was passed to `runModel`.
     */
    getOutputsObject(): Outputs | undefined;
    /**
     * Store the output values that were written by the model.  This will be used to populate
     * the `Outputs` object that was passed to the latest `runModel` call.
     *
     * @param array The array that contains the output values.
     */
    storeOutputs(array: Float64Array): void;
    /**
     * Return an array containing lookup overrides, or undefined if no lookups were passed to
     * the latest `runModel` call.
     */
    getLookups(): LookupDef[] | undefined;
    /**
     * Return the elapsed time (in milliseconds) of the model run.
     */
    getElapsedTime(): number;
    /**
     * Store the elapsed time of the model run.
     *
     * @param elapsed The model run time, in milliseconds.
     */
    storeElapsedTime(elapsed: number): void;
}

/**
 * An implementation of `RunModelParams` that copies the input and output arrays into a single,
 * combined buffer.  This implementation is designed to work with an asynchronous `ModelRunner`
 * implementation because the buffer can be transferred to/from a Web Worker or Node.js worker
 * thread without copying (if it is marked `Transferable`).
 *
 * @hidden This is not yet exposed in the public API; it is currently only used by
 * the implementations of the `RunnableModel` interface.
 */
declare class BufferedRunModelParams implements RunModelParams {
    private readonly listing?;
    /**
     * The array that holds all input and output values.  This is grown as needed.  The memory
     * layout of the buffer is as follows:
     *   header
     *   extras (holds elapsed time, etc)
     *   inputs
     *   outputs
     *   outputIndices
     *   lookups (data)
     *   lookupIndices
     */
    private encoded;
    /**
     * The header section of the `encoded` buffer.  The header declares the byte offset and length
     * (in elements) of each section of the buffer.
     */
    private readonly header;
    /** The extras section of the `encoded` buffer (holds elapsed time, etc). */
    private readonly extras;
    /** The inputs section of the `encoded` buffer. */
    private readonly inputs;
    /** The outputs section of the `encoded` buffer. */
    private readonly outputs;
    /** The output indices section of the `encoded` buffer. */
    private readonly outputIndices;
    /** The lookup data section of the `encoded` buffer. */
    private readonly lookups;
    /** The lookup indices section of the `encoded` buffer. */
    private readonly lookupIndices;
    /**
     * @param listing The model listing that is used to locate a variable that is referenced by
     * name or identifier.  If undefined, variables cannot be referenced by name or identifier,
     * and can only be referenced using a valid `VarSpec`.
     */
    constructor(listing?: ModelListing);
    /**
     * Return the encoded buffer from this instance, which can be passed to `updateFromEncodedBuffer`.
     */
    getEncodedBuffer(): ArrayBuffer;
    getInputs(): Float64Array | undefined;
    copyInputs(array: Float64Array | undefined, create: (numElements: number) => Float64Array): void;
    getOutputIndicesLength(): number;
    getOutputIndices(): Int32Array | undefined;
    copyOutputIndices(array: Int32Array | undefined, create: (numElements: number) => Int32Array): void;
    getOutputsLength(): number;
    getOutputs(): Float64Array | undefined;
    getOutputsObject(): Outputs | undefined;
    storeOutputs(array: Float64Array): void;
    getLookups(): LookupDef[] | undefined;
    getElapsedTime(): number;
    storeElapsedTime(elapsed: number): void;
    /**
     * Copy the outputs buffer to the given `Outputs` instance.  This should be called
     * after the `runModel` call has completed so that the output values are copied from
     * the internal buffer to the `Outputs` instance that was passed to `runModel`.
     *
     * @param outputs The `Outputs` instance into which the output values will be copied.
     */
    finalizeOutputs(outputs: Outputs): void;
    /**
     * Update this instance using the parameters that are passed to a `runModel` call.
     *
     * @param inputs The model input values (must be in the same order as in the spec file).
     * @param outputs The structure into which the model outputs will be stored.
     * @param options Additional options that influence the model run.
     */
    updateFromParams(inputs: number[] | InputValue[], outputs: Outputs, options?: RunModelOptions): void;
    /**
     * Update this instance using the values contained in the encoded buffer from another
     * `BufferedRunModelParams` instance.
     *
     * @param buffer An encoded buffer returned by `getEncodedBuffer`.
     */
    updateFromEncodedBuffer(buffer: ArrayBuffer): void;
}

/**
 * An implementation of `RunModelParams` that keeps references to the `inputs` and
 * `outputs` parameters that are passed to the `runModel` function.  This implementation
 * is best used with a synchronous `ModelRunner`.
 *
 * @hidden This is not yet exposed in the public API; it is currently only used by
 * the implementations of the `RunnableModel` interface.
 */
declare class ReferencedRunModelParams implements RunModelParams {
    private readonly listing?;
    private inputs;
    private outputs;
    private outputsLengthInElements;
    private outputIndicesLengthInElements;
    private lookups;
    /**
     * @param listing The model listing that is used to locate a variable that is referenced by
     * name or identifier.  If undefined, variables cannot be referenced by name or identifier,
     * and can only be referenced using a valid `VarSpec`.
     */
    constructor(listing?: ModelListing);
    getInputs(): Float64Array | undefined;
    copyInputs(array: Float64Array | undefined, create: (numElements: number) => Float64Array): void;
    getOutputIndicesLength(): number;
    getOutputIndices(): Int32Array | undefined;
    copyOutputIndices(array: Int32Array | undefined, create: (numElements: number) => Int32Array): void;
    getOutputsLength(): number;
    getOutputs(): Float64Array | undefined;
    getOutputsObject(): Outputs | undefined;
    storeOutputs(array: Float64Array): void;
    getLookups(): LookupDef[] | undefined;
    getElapsedTime(): number;
    storeElapsedTime(elapsed: number): void;
    /**
     * Update this instance using the parameters that are passed to a `runModel` call.
     *
     * @param inputs The model input values (must be in the same order as in the spec file).
     * @param outputs The structure into which the model outputs will be stored.
     * @param options Additional options that influence the model run.
     */
    updateFromParams(inputs: number[] | InputValue[], outputs: Outputs, options?: RunModelOptions): void;
}

/**
 * This interface exposes the properties and functions that allow a `ModelRunner`
 * implementation to run a model that was generated by the SDEverywhere transpiler.
 * The `runModel` method will synchronously run the wrapped model with a provided
 * set of input and output parameters.
 *
 * @hidden This is not yet exposed in the public API; it is currently only used by
 * the internal implementations of this interface, and from the runtime-async package.
 */
interface RunnableModel {
    /** The start time for the model (aka `INITIAL TIME`). */
    readonly startTime: number;
    /** The end time for the model (aka `FINAL TIME`). */
    readonly endTime: number;
    /** The frequency with which output values are saved (aka `SAVEPER`). */
    readonly saveFreq: number;
    /** The number of save points for each output. */
    readonly numSavePoints: number;
    /** The output variable IDs for this model. */
    readonly outputVarIds: OutputVarId[];
    /**
     * The model listing that is used to resolve variables.  This can be undefined,
     * in which case variables cannot be referenced by name or identifier, and can only
     * be referenced using a valid `VarSpec`.
     */
    readonly modelListing?: any;
    /**
     * Run the model synchronously on the current thread.
     *
     * @param params The parameters that control the model run.
     */
    runModel(params: RunModelParams): void;
    /**
     * Terminate the runner by releasing underlying resources (e.g., the worker thread or
     * Wasm module/buffers).
     */
    terminate(): void;
}

type JsModelLookupMode = 'interpolate' | 'forward' | 'backward';
/**
 * @hidden This is not yet part of the public API; for internal use only.
 */
declare class JsModelLookup {
    private readonly n;
    private readonly data;
    private invertedData?;
    private lastInput;
    private lastHitIndex;
    /**
     * @param n The number of (x,y) pairs in the lookup.
     * @param data The lookup data, as (x,y) pairs.  The length of the array must be
     * >= 2*n.  Note that the data will be stored by reference, so if there is a chance
     * that the array will be reused or modified by other code, be sure to pass in a
     * copy of the array.
     */
    constructor(n: number, data: number[] | Float64Array);
    getValueForX(x: number, mode: JsModelLookupMode): number;
    getValueForY(y: number): number;
    /**
     * Interpolate the y value from the array of (x,y) pairs.
     * NOTE: The x values are assumed to be monotonically increasing.
     */
    private getValue;
    /**
     * Return the most appropriate y value from the array of (x,y) pairs when
     * this instance is used to provide inputs for the `GAME` function.
     *
     * NOTE: The x values are assumed to be monotonically increasing.
     *
     * This method is similar to `getValueForX` in concept, except that this one
     * returns the provided `defaultValue` if the `time` parameter is earlier than
     * the first data point in the lookup.  Also, this method always uses the
     * `backward` interpolation mode, meaning that it holds the "current" value
     * constant instead of interpolating.
     *
     * @param time The time that is used to select the data point that has an
     * `x` value less than or equal to the provided time.
     * @param defaultValue The value that is returned if this lookup is empty (has
     * no points) or if the provided time is earlier than the first data point.
     */
    getValueForGameTime(time: number, defaultValue: number): number;
    /**
     * Interpolate the y value from the array of (x,y) pairs.
     * NOTE: The x values are assumed to be monotonically increasing.
     *
     * This method is similar to `getValue` in concept, but Vensim produces results for
     * the `GET DATA BETWEEN TIMES` function that differ in unexpected ways from normal
     * lookup behavior, so we implement it as a separate method here.
     */
    getValueBetweenTimes(input: number, mode: JsModelLookupMode): number;
}

/**
 * Provides access to the minimal set of control parameters that are used in the
 * implementation of certain model functions.
 *
 * @hidden This is not yet part of the public API; for internal use by generated
 * `JsModel` implementations.
 */
interface JsModelFunctionContext {
    timeStep: number;
    currentTime: number;
}
/**
 * Exposes all the model function implementations that are called by a `JsModel` at runtime.
 *
 * @hidden This is not yet part of the public API; for internal use by generated
 * `JsModel` implementations.
 */
interface JsModelFunctions {
    setContext(context: JsModelFunctionContext): void;
    ABS(x: number): number;
    ARCCOS(x: number): number;
    ARCSIN(x: number): number;
    ARCTAN(x: number): number;
    COS(x: number): number;
    EXP(x: number): number;
    GAME(inputs: JsModelLookup, x: number): number;
    INTEG(value: number, rate: number): number;
    INTEGER(x: number): number;
    LN(x: number): number;
    MAX(x: number, y: number): number;
    MIN(x: number, y: number): number;
    MODULO(x: number, y: number): number;
    POW(x: number, y: number): number;
    POWER(x: number, y: number): number;
    PULSE(start: number, width: number): number;
    PULSE_TRAIN(start: number, width: number, interval: number, end: number): number;
    QUANTUM(x: number, y: number): number;
    RAMP(slope: number, startTime: number, endTime: number): number;
    SIN(x: number): number;
    SQRT(x: number): number;
    STEP(height: number, stepTime: number): number;
    TAN(x: number): number;
    VECTOR_SORT_ORDER(vector: number[], size: number, direction: number): number[];
    XIDZ(a: number, b: number, x: number): number;
    ZIDZ(a: number, b: number): number;
    createLookup(size: number, data: number[] | Float64Array): JsModelLookup;
    LOOKUP(lookup: JsModelLookup, x: number): number;
    LOOKUP_FORWARD(lookup: JsModelLookup, x: number): number;
    LOOKUP_BACKWARD(lookup: JsModelLookup, x: number): number;
    LOOKUP_INVERT(lookup: JsModelLookup, y: number): number;
    WITH_LOOKUP(x: number, lookup: JsModelLookup): number;
    GET_DATA_BETWEEN_TIMES(lookup: JsModelLookup, x: number, mode: number): number;
}
/**
 * Returns a default implementation of the `JsModelFunctions` interface.  If needed,
 * you can provide a custom implementation of any exposed function by overriding
 * (setting) a new function implementation on the returned instance.
 *
 * @hidden This is not yet part of the public API; for internal use by generated
 * `JsModel` implementations.
 */
declare function getJsModelFunctions(): JsModelFunctions;

/**
 * An interface that exposes the functions of a JavaScript model generated by the
 * SDEverywhere transpiler.  This allows for running the model with a given set of
 * input values, which will produce a set of output values.
 *
 * This is a low-level interface that most developers will not need to interact
 * with directly.  Developers should instead use the `ModelRunner` interface to
 * interact with a generated model.  Use `createSynchronousModelRunner` to create
 * a synchronous `ModelRunner`, or `spawnAsyncModelRunner` to create an asynchronous
 * `ModelRunner`.
 *
 * @beta NOTE: The properties and methods exposed in this interface are meant for
 * internal use only, and are subject to change in coordination with the code
 * generated by the `@sdeverywhere/compile` package.
 */
interface JsModel {
    readonly kind: 'js';
    readonly outputVarIds: string[];
    readonly outputVarNames: string[];
    readonly modelListing?: any;
    /** @hidden */
    getInitialTime(): number;
    /** @hidden */
    getFinalTime(): number;
    /** @hidden */
    getTimeStep(): number;
    /** @hidden */
    getSaveFreq(): number;
    /** @hidden */
    getModelFunctions(): JsModelFunctions;
    /** @hidden */
    setModelFunctions(functions: JsModelFunctions): void;
    /** @hidden */
    setTime(time: number): void;
    /** @hidden */
    setInputs(inputValue: (index: number) => number): void;
    /** @hidden */
    setLookup(varSpec: VarSpec, points: Float64Array): void;
    /** @hidden */
    storeOutputs(storeValue: (value: number) => void): void;
    /** @hidden */
    storeOutput(varSpec: VarSpec, storeValue: (value: number) => void): void;
    /** @hidden */
    initConstants(): void;
    /** @hidden */
    initLevels(): void;
    /** @hidden */
    evalAux(): void;
    /** @hidden */
    evalLevels(): void;
}
/**
 * Create a `RunnableModel` from a given `JsModel` that was generated by the
 * SDEverywhere transpiler.
 *
 * @hidden This is not part of the public API; only the top-level `createRunnableModel`
 * function is exposed in the public API.
 */
declare function initJsModel(model: JsModel): RunnableModel;

/**
 * Run the given model synchronously and log the output values to the console in
 * TSV (tab-separated values) format.
 *
 * @hidden This is mainly intended for use in implementing the `sde exec` command,
 * so isn't exposed in the public API at this time.
 *
 * @param jsModel A `JsModel` instance.
 */
declare function execJsModel(jsModel: JsModel): void;

/**
 * @hidden This type is not part of the public API; it is exposed only for use in
 * tests in the runtime-async package.
 */
type OnEvalAux = (vars: Map<VarId, number>, lookups: Map<VarId, JsModelLookup>) => void;
/**
 * @hidden This type is not part of the public API; it is exposed only for use in
 * tests in the runtime-async package.
 */
declare class MockJsModel implements JsModel {
    readonly kind = "js";
    readonly outputVarIds: OutputVarId[];
    readonly outputVarNames: OutputVarId[];
    readonly modelListing?: any;
    private readonly internalListing?;
    private readonly initialTime;
    private readonly finalTime;
    private readonly vars;
    private readonly lookups;
    private fns;
    readonly onEvalAux: OnEvalAux;
    constructor(options: {
        initialTime: number;
        finalTime: number;
        outputVarIds: OutputVarId[];
        listingJson?: string;
        onEvalAux: OnEvalAux;
    });
    varIdForSpec(varSpec: VarSpec): VarId;
    getInitialTime(): number;
    getFinalTime(): number;
    getTimeStep(): number;
    getSaveFreq(): number;
    getModelFunctions(): JsModelFunctions;
    setModelFunctions(fns: JsModelFunctions): void;
    setTime(time: number): void;
    setInputs(): void;
    setLookup(varSpec: VarSpec, points: Float64Array): void;
    storeOutputs(storeValue: (value: number) => void): void;
    storeOutput(varSpec: VarSpec, storeValue: (value: number) => void): void;
    initConstants(): void;
    initLevels(): void;
    evalAux(): void;
    evalLevels(): void;
}

/**
 * Type declaration for a WebAssembly module wrapper produced
 * by the Emscripten compiler.  This only declares the minimal
 * set of fields needed by the SDEverywhere runtime.
 */
interface WasmModule {
    readonly kind: 'wasm';
    readonly outputVarIds: OutputVarId[];
    readonly modelListing?: any;
    /** @hidden */
    cwrap: (fname: string, rettype: string, argtypes: string[]) => any;
    /** @hidden */
    _malloc: (numBytes: number) => number;
    /** @hidden */
    _free: (byteOffset: number) => void;
    /** @hidden */
    HEAP32: Int32Array;
    /** @hidden */
    HEAPF64: Float64Array;
}

/**
 * Initialize the wasm model.
 *
 * @hidden This is not part of the public API; only the top-level `createRunnableModel`
 * function is exposed in the public API.
 *
 * @param wasmModule The `WasmModule` that wraps the `wasm` binary.
 * @return The initialized `WasmModel` instance.
 */
declare function initWasmModel(wasmModule: WasmModule): RunnableModel;

/**
 * @hidden This type is not part of the public API; it is exposed only for use in
 * tests in the runtime-async package.
 */
type OnRunModel = (inputs: Float64Array, outputs: Float64Array, lookups: Map<VarId, JsModelLookup>, outputIndices?: Int32Array) => void;
/**
 * @hidden This type is not part of the public API; it is exposed only for use in
 * tests in the runtime-async package.
 */
declare class MockWasmModule implements WasmModule {
    readonly kind = "wasm";
    readonly outputVarIds: OutputVarId[];
    readonly modelListing?: any;
    private readonly internalListing?;
    private readonly initialTime;
    private readonly finalTime;
    private readonly heap;
    readonly HEAP32: Int32Array;
    readonly HEAPF64: Float64Array;
    private mallocOffset;
    private readonly allocs;
    private readonly lookups;
    readonly onRunModel: OnRunModel;
    constructor(options: {
        initialTime: number;
        finalTime: number;
        outputVarIds: string[];
        listingJson?: string;
        onRunModel: OnRunModel;
    });
    varIdForSpec(varSpec: VarSpec): VarId;
    cwrap(fname: string): (varIndex: number, _subIndicesAddress: number, pointsAddress: number, numPoints: number) => void;
    _malloc(lengthInBytes: number): number;
    _free(): void;
    private getHeapView;
}

/**
 * Abstraction that allows for running the wasm model on the JS thread
 * or asynchronously (e.g. in a Web Worker), depending on the implementation.
 */
interface ModelRunner {
    /**
     * Create an `Outputs` instance that is sized to accommodate the output variable
     * data stored by the model.
     *
     * @return A new `Outputs` instance.
     */
    createOutputs(): Outputs;
    /**
     * Run the model.
     *
     * @param inputs The model input values (must be in the same order as in the spec file).
     * @param outputs The structure into which the model outputs will be stored.
     * @param options Additional options that influence the model run.
     * @return A promise that resolves with the outputs when the model run is complete.
     */
    runModel(inputs: number[] | InputValue[], outputs: Outputs, options?: RunModelOptions): Promise<Outputs>;
    /**
     * Run the model synchronously.
     *
     * @param inputs The model input values (must be in the same order as in the spec file).
     * @param outputs The structure into which the model outputs will be stored.
     * @param options Additional options that influence the model run.
     * @return The outputs of the run.
     *
     * @hidden This is only intended for internal use; some implementations may not support
     * running the model synchronously, in which case this will be undefined.
     */
    runModelSync?(inputs: number[] | InputValue[], outputs: Outputs, options?: RunModelOptions): Outputs;
    /**
     * Terminate the runner by releasing underlying resources (e.g., the worker thread or
     * Wasm module/buffers).
     */
    terminate(): Promise<void>;
}

/** Union of model types that are generated by the SDEverywhere transpiler/builder. */
type GeneratedModel = JsModel | WasmModule;
/**
 * Create a `RunnableModel` from a given `JsModel` or `WasmModule` that was generated by the
 * SDEverywhere transpiler/builder.
 *
 * @hidden This is not yet part of the public API; it is only exposed for use by
 * the runtime-async package.
 */
declare function createRunnableModel(generatedModel: GeneratedModel): RunnableModel;
/**
 * Create a `ModelRunner` that runs a generated model on the JS thread.
 *
 * @param generatedModel A `JsModel` or `WasmModule` generated by the SDEverywhere transpiler.
 */
declare function createSynchronousModelRunner(generatedModel: GeneratedModel): ModelRunner;

/**
 * A high-level interface that schedules running of the underlying `WasmModel`.
 *
 * When one or more input values are changed, this class will schedule a model
 * run to be completed as soon as possible.  When the model run has completed,
 * `onOutputsChanged` is called to notify that new output data is available.
 *
 * The `ModelRunner` is pluggable to allow for running the model synchronously
 * (on the main JavaScript thread) or asynchronously (in a Web Worker or Node.js
 * worker thread).
 */
declare class ModelScheduler {
    private readonly runner;
    private readonly userInputs;
    private outputs;
    /** The second array that holds a stable copy of the user inputs. */
    private readonly currentInputs;
    /** Whether a model run has been scheduled. */
    private runNeeded;
    /** Whether a model run is in progress. */
    private runInProgress;
    /** Called when `outputs` has been updated after a model run. */
    onOutputsChanged?: (outputs: Outputs) => void;
    /**
     * @param runner The model runner.
     * @param userInputs The input values, in the same order as in the spec file passed to `sde`.
     * @param outputs The structure into which the model outputs will be stored.
     */
    constructor(runner: ModelRunner, userInputs: InputValue[], outputs: Outputs);
    /**
     * Schedule a wasm model run (if not already pending).  When the run is
     * complete, save the outputs and call the `onOutputsChanged` callback.
     */
    private runWasmModelIfNeeded;
    /**
     * Run the wasm model asynchronously using the current set of input values.
     */
    private runWasmModelNow;
}

/**
 * Return a timestamp that can be passed to `perfElapsed` for calculating the elapsed
 * time of an operation.
 *
 * @hidden This is not part of the public API; exposed only for use in performance testing.
 */
declare function perfNow(): unknown;
/**
 * Return the elapsed time between the given timestamp (created by `perfNow`) and now.
 *
 * @hidden This is not part of the public API; exposed only for use in performance testing.
 */
declare function perfElapsed(t0: unknown): number;

export { BufferedRunModelParams, type GeneratedModel, type InputCallbacks, type InputValue, type InputVarId, type JsModel, type JsModelFunctionContext, type JsModelFunctions, type LookupDef, MockJsModel, MockWasmModule, ModelListing, type ModelListingSpecs, type ModelRunner, ModelScheduler, type OnEvalAux, type OnRunModel, type OutputVarId, Outputs, type ParseError, type Point, ReferencedRunModelParams, type RunModelOptions, type RunModelParams, type RunnableModel, Series, type VarId, type VarName, type VarRef, type VarSpec, type WasmModule, createInputValue, createLookupDef, createRunnableModel, createSynchronousModelRunner, decodeLookups, encodeLookups, encodeVarIndices, execJsModel, getEncodedLookupBufferLengths, getEncodedVarIndicesLength, getJsModelFunctions, initJsModel, initWasmModel, perfElapsed, perfNow };
