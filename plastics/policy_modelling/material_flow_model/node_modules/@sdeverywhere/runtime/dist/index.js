var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/_shared/inputs.ts
function createInputValue(varId, defaultValue, initialValue) {
  let currentValue = initialValue !== void 0 ? initialValue : defaultValue;
  const callbacks = {};
  const get = () => {
    return currentValue;
  };
  const set = (newValue) => {
    var _a;
    if (newValue !== currentValue) {
      currentValue = newValue;
      (_a = callbacks.onSet) == null ? void 0 : _a.call(callbacks);
    }
  };
  const reset = () => {
    set(defaultValue);
  };
  return { varId, get, set, reset, callbacks };
}

// src/_shared/outputs.ts
import { ok, err } from "neverthrow";
var Series = class _Series {
  /**
   * @param varId The ID for the output variable (as used by SDEverywhere).
   * @param points The data points for the variable, one point per time increment.
   */
  constructor(varId, points) {
    this.varId = varId;
    this.points = points;
  }
  /**
   * Return the Y value at the given time.  Note that this does not attempt to interpolate
   * if there is no data point defined for the given time and will return undefined in
   * that case.
   *
   * @param time The x (time) value.
   * @return The y value for the given time, or undefined if there is no data point defined
   * for the given time.
   */
  getValueAtTime(time) {
    var _a;
    return (_a = this.points.find((p) => p.x === time)) == null ? void 0 : _a.y;
  }
  /**
   * Create a new `Series` instance that is a copy of this one.
   */
  copy() {
    const pointsCopy = this.points.map((p) => __spreadValues({}, p));
    return new _Series(this.varId, pointsCopy);
  }
};
var Outputs = class {
  /**
   * @param varIds The output variable identifiers.
   * @param startTime The start time for the model.
   * @param endTime The end time for the model.
   * @param saveFreq The frequency with which output values are saved (aka `SAVEPER`).
   */
  constructor(varIds, startTime, endTime, saveFreq = 1) {
    this.varIds = varIds;
    this.startTime = startTime;
    this.endTime = endTime;
    this.saveFreq = saveFreq;
    this.seriesLength = Math.round((endTime - startTime) / saveFreq) + 1;
    this.varSeries = new Array(varIds.length);
    for (let i = 0; i < varIds.length; i++) {
      const points = new Array(this.seriesLength);
      for (let j = 0; j < this.seriesLength; j++) {
        points[j] = { x: startTime + j * saveFreq, y: 0 };
      }
      const varId = varIds[i];
      this.varSeries[i] = new Series(varId, points);
    }
  }
  /**
   * The optional set of specs that dictate which variables from the model will be
   * stored in this `Outputs` instance.  If undefined, the default set of outputs
   * will be stored (as configured in `varIds`).
   * @hidden This is not yet part of the public API; it is exposed here for use
   * in experimental testing tools.
   */
  setVarSpecs(varSpecs) {
    if (varSpecs.length !== this.varIds.length) {
      throw new Error("Length of output varSpecs must match that of varIds");
    }
    this.varSpecs = varSpecs;
  }
  /**
   * Parse the given raw float buffer (produced by the model) and store the values
   * into this `Outputs` instance.
   *
   * Note that the length of `outputsBuffer` must be greater than or equal to
   * the capacity of this `Outputs` instance.  The `Outputs` instance is allowed
   * to be smaller to support the case where you want to extract a subset of
   * the time range in the buffer produced by the model.
   *
   * @param outputsBuffer The raw outputs buffer produced by the model.
   * @param rowLength The number of elements per row (one element per save point).
   * @return An `ok` result if the buffer is valid, otherwise an `err` result.
   */
  updateFromBuffer(outputsBuffer, rowLength) {
    const result = parseOutputsBuffer(outputsBuffer, rowLength, this);
    if (result.isOk()) {
      return ok(void 0);
    } else {
      return err(result.error);
    }
  }
  /**
   * Return the series for the given output variable.
   *
   * @param varId The ID of the output variable (as used by SDEverywhere).
   */
  getSeriesForVar(varId) {
    const seriesIndex = this.varIds.indexOf(varId);
    if (seriesIndex >= 0) {
      return this.varSeries[seriesIndex];
    } else {
      return void 0;
    }
  }
};
function parseOutputsBuffer(outputsBuffer, rowLength, outputs) {
  const varCount = outputs.varIds.length;
  const seriesLength = outputs.seriesLength;
  if (rowLength < seriesLength || outputsBuffer.length < varCount * seriesLength) {
    return err("invalid-point-count");
  }
  for (let outputVarIndex = 0; outputVarIndex < varCount; outputVarIndex++) {
    const series = outputs.varSeries[outputVarIndex];
    let sourceIndex = rowLength * outputVarIndex;
    for (let valueIndex = 0; valueIndex < seriesLength; valueIndex++) {
      series.points[valueIndex].y = validateNumber(outputsBuffer[sourceIndex]);
      sourceIndex++;
    }
  }
  return ok(outputs);
}
function validateNumber(x) {
  if (!isNaN(x) && x > -1e32) {
    return x;
  } else {
    return void 0;
  }
}

// src/_shared/var-indices.ts
function getEncodedVarIndicesLength(varSpecs) {
  var _a;
  let length = 1;
  for (const varSpec of varSpecs) {
    length += 2;
    const subCount = ((_a = varSpec.subscriptIndices) == null ? void 0 : _a.length) || 0;
    length += subCount;
  }
  return length;
}
function encodeVarIndices(varSpecs, indicesArray) {
  let offset = 0;
  indicesArray[offset++] = varSpecs.length;
  for (const varSpec of varSpecs) {
    indicesArray[offset++] = varSpec.varIndex;
    const subs = varSpec.subscriptIndices;
    const subCount = (subs == null ? void 0 : subs.length) || 0;
    indicesArray[offset++] = subCount;
    for (let i = 0; i < subCount; i++) {
      indicesArray[offset++] = subs[i];
    }
  }
}
function getEncodedLookupBufferLengths(lookupDefs) {
  var _a;
  let lookupIndicesLength = 1;
  let lookupsLength = 0;
  for (const lookupDef of lookupDefs) {
    const varSpec = lookupDef.varRef.varSpec;
    if (varSpec === void 0) {
      throw new Error("Cannot compute lookup buffer lengths until all lookup var specs are defined");
    }
    lookupIndicesLength += 2;
    const subCount = ((_a = varSpec.subscriptIndices) == null ? void 0 : _a.length) || 0;
    lookupIndicesLength += subCount;
    lookupIndicesLength += 2;
    lookupsLength += lookupDef.points.length;
  }
  return {
    lookupIndicesLength,
    lookupsLength
  };
}
function encodeLookups(lookupDefs, lookupIndicesArray, lookupsArray) {
  let li = 0;
  lookupIndicesArray[li++] = lookupDefs.length;
  let lookupDataOffset = 0;
  for (const lookupDef of lookupDefs) {
    const varSpec = lookupDef.varRef.varSpec;
    lookupIndicesArray[li++] = varSpec.varIndex;
    const subs = varSpec.subscriptIndices;
    const subCount = (subs == null ? void 0 : subs.length) || 0;
    lookupIndicesArray[li++] = subCount;
    for (let i = 0; i < subCount; i++) {
      lookupIndicesArray[li++] = subs[i];
    }
    lookupIndicesArray[li++] = lookupDataOffset;
    lookupIndicesArray[li++] = lookupDef.points.length;
    lookupsArray == null ? void 0 : lookupsArray.set(lookupDef.points, lookupDataOffset);
    lookupDataOffset += lookupDef.points.length;
  }
}
function decodeLookups(lookupIndicesArray, lookupsArray) {
  const lookupDefs = [];
  let li = 0;
  const lookupCount = lookupIndicesArray[li++];
  for (let i = 0; i < lookupCount; i++) {
    const varIndex = lookupIndicesArray[li++];
    const subCount = lookupIndicesArray[li++];
    const subscriptIndices = subCount > 0 ? Array(subCount) : void 0;
    for (let subIndex = 0; subIndex < subCount; subIndex++) {
      subscriptIndices[subIndex] = lookupIndicesArray[li++];
    }
    const lookupDataOffset = lookupIndicesArray[li++];
    const lookupDataLength = lookupIndicesArray[li++];
    const varSpec = {
      varIndex,
      subscriptIndices
    };
    let points;
    if (lookupsArray) {
      points = lookupsArray.slice(lookupDataOffset, lookupDataOffset + lookupDataLength);
    } else {
      points = new Float64Array(0);
    }
    lookupDefs.push({
      varRef: {
        varSpec
      },
      points
    });
  }
  return lookupDefs;
}

// src/_shared/lookup-def.ts
function createLookupDef(varRef, points) {
  const flatPoints = new Float64Array(points.length * 2);
  let i = 0;
  for (const p of points) {
    flatPoints[i++] = p.x;
    flatPoints[i++] = p.y;
  }
  return {
    varRef,
    points: flatPoints
  };
}

// src/model-listing/model-listing.ts
var ModelListing = class {
  constructor(listingObj) {
    this.varSpecs = /* @__PURE__ */ new Map();
    const dimensions = /* @__PURE__ */ new Map();
    for (const dimInfo of listingObj.dimensions) {
      const dimId = dimInfo.id;
      const subscripts = [];
      for (let i = 0; i < dimInfo.subIds.length; i++) {
        subscripts.push({
          id: dimInfo.subIds[i],
          index: i
        });
      }
      dimensions.set(dimId, {
        id: dimId,
        subscripts
      });
    }
    function dimensionForId(dimId) {
      const dim = dimensions.get(dimId);
      if (dim === void 0) {
        throw new Error(`No dimension info found for id=${dimId}`);
      }
      return dim;
    }
    const baseVarIds = /* @__PURE__ */ new Set();
    for (const v of listingObj.variables) {
      const baseVarId = varIdWithoutSubscripts(v.id);
      if (!baseVarIds.has(baseVarId)) {
        const dimIds = v.dimIds || [];
        const dimensions2 = dimIds.map(dimensionForId);
        if (dimensions2.length > 0) {
          const dimSubs = [];
          for (const dim of dimensions2) {
            dimSubs.push(dim.subscripts);
          }
          const combos = cartesianProductOf(dimSubs);
          for (const combo of combos) {
            const subs = combo.map((sub) => sub.id).join(",");
            const subIndices = combo.map((sub) => sub.index);
            const fullVarId = `${baseVarId}[${subs}]`;
            this.varSpecs.set(fullVarId, {
              varIndex: v.index,
              subscriptIndices: subIndices
            });
          }
        } else {
          this.varSpecs.set(baseVarId, {
            varIndex: v.index
          });
        }
        baseVarIds.add(baseVarId);
      }
    }
  }
  /**
   * Return the `VarSpec` for the given variable ID, or undefined if there is no spec defined
   * in the listing for that variable.
   */
  getSpecForVarId(varId) {
    return this.varSpecs.get(varId);
  }
  /**
   * Return the `VarSpec` for the given variable name, or undefined if there is no spec defined
   * in the listing for that variable.
   */
  getSpecForVarName(varName) {
    const varId = sdeVarIdForVensimVarName(varName);
    return this.varSpecs.get(varId);
  }
  /**
   * Create a new `Outputs` instance that uses the same start/end years as the given "normal"
   * `Outputs` instance but is prepared for reading the specified internal variables from the model.
   *
   * @param normalOutputs The `Outputs` that is used to access normal output variables from the model.
   * @param varIds The variable IDs to include with the new `Outputs` instance.
   */
  deriveOutputs(normalOutputs, varIds) {
    const varSpecs = [];
    for (const varId of varIds) {
      const varSpec = this.varSpecs.get(varId);
      if (varSpec !== void 0) {
        varSpecs.push(varSpec);
      } else {
        console.warn(`WARNING: No output var spec found for id=${varId}`);
      }
    }
    const newOutputs = new Outputs(varIds, normalOutputs.startTime, normalOutputs.endTime, normalOutputs.saveFreq);
    newOutputs.varSpecs = varSpecs;
    return newOutputs;
  }
};
function varIdWithoutSubscripts(fullVarId) {
  const bracketIndex = fullVarId.indexOf("[");
  if (bracketIndex >= 0) {
    return fullVarId.substring(0, bracketIndex);
  } else {
    return fullVarId;
  }
}
function cartesianProductOf(arr) {
  return arr.reduce(
    (a, b) => {
      return a.map((x) => b.map((y) => x.concat([y]))).reduce((v, w) => v.concat(w), []);
    },
    [[]]
  );
}
function sdeVarIdForVensimName(name) {
  return "_" + name.trim().replace(/"/g, "_").replace(/\s+!$/g, "!").replace(/\s/g, "_").replace(/,/g, "_").replace(/-/g, "_").replace(/\./g, "_").replace(/\$/g, "_").replace(/'/g, "_").replace(/&/g, "_").replace(/%/g, "_").replace(/\//g, "_").replace(/\|/g, "_").toLowerCase();
}
function sdeVarIdForVensimVarName(varName) {
  const m = varName.match(/([^[]+)(?:\[([^\]]+)\])?/);
  if (!m) {
    throw new Error(`Invalid Vensim name: ${varName}`);
  }
  let id = sdeVarIdForVensimName(m[1]);
  if (m[2]) {
    const subscripts = m[2].split(",").map((x) => sdeVarIdForVensimName(x));
    id += `[${subscripts.join(",")}]`;
  }
  return id;
}

// src/runnable-model/resolve-var-ref.ts
function resolveVarRef(listing, varRef, varKind) {
  if (varRef.varSpec) {
    return;
  }
  if (listing === void 0) {
    throw new Error(
      `Unable to resolve ${varKind} variable references by name or identifier when model listing is unavailable`
    );
  }
  if (varRef.varId) {
    const varSpec = listing == null ? void 0 : listing.getSpecForVarId(varRef.varId);
    if (varSpec) {
      varRef.varSpec = varSpec;
    } else {
      throw new Error(`Failed to resolve ${varKind} variable reference for varId=${varRef.varId}`);
    }
  } else {
    const varSpec = listing == null ? void 0 : listing.getSpecForVarName(varRef.varName);
    if (varSpec) {
      varRef.varSpec = varSpec;
    } else {
      throw new Error(`Failed to resolve ${varKind} variable reference for varName='${varRef.varId}'`);
    }
  }
}

// src/runnable-model/buffered-run-model-params.ts
var headerLengthInElements = 16;
var extrasLengthInElements = 1;
var Int32Section = class {
  constructor() {
    this.offsetInBytes = 0;
    this.lengthInElements = 0;
  }
  update(encoded, offsetInBytes, lengthInElements) {
    this.view = lengthInElements > 0 ? new Int32Array(encoded, offsetInBytes, lengthInElements) : void 0;
    this.offsetInBytes = offsetInBytes;
    this.lengthInElements = lengthInElements;
  }
};
var Float64Section = class {
  constructor() {
    this.offsetInBytes = 0;
    this.lengthInElements = 0;
  }
  update(encoded, offsetInBytes, lengthInElements) {
    this.view = lengthInElements > 0 ? new Float64Array(encoded, offsetInBytes, lengthInElements) : void 0;
    this.offsetInBytes = offsetInBytes;
    this.lengthInElements = lengthInElements;
  }
};
var BufferedRunModelParams = class {
  /**
   * @param listing The model listing that is used to locate a variable that is referenced by
   * name or identifier.  If undefined, variables cannot be referenced by name or identifier,
   * and can only be referenced using a valid `VarSpec`.
   */
  constructor(listing) {
    this.listing = listing;
    /**
     * The header section of the `encoded` buffer.  The header declares the byte offset and length
     * (in elements) of each section of the buffer.
     */
    this.header = new Int32Section();
    /** The extras section of the `encoded` buffer (holds elapsed time, etc). */
    this.extras = new Float64Section();
    /** The inputs section of the `encoded` buffer. */
    this.inputs = new Float64Section();
    /** The outputs section of the `encoded` buffer. */
    this.outputs = new Float64Section();
    /** The output indices section of the `encoded` buffer. */
    this.outputIndices = new Int32Section();
    /** The lookup data section of the `encoded` buffer. */
    this.lookups = new Float64Section();
    /** The lookup indices section of the `encoded` buffer. */
    this.lookupIndices = new Int32Section();
  }
  /**
   * Return the encoded buffer from this instance, which can be passed to `updateFromEncodedBuffer`.
   */
  getEncodedBuffer() {
    return this.encoded;
  }
  // from RunModelParams interface
  getInputs() {
    return this.inputs.view;
  }
  // from RunModelParams interface
  copyInputs(array, create) {
    if (this.inputs.lengthInElements === 0) {
      return;
    }
    if (array === void 0 || array.length < this.inputs.lengthInElements) {
      array = create(this.inputs.lengthInElements);
    }
    array.set(this.inputs.view);
  }
  // from RunModelParams interface
  getOutputIndicesLength() {
    return this.outputIndices.lengthInElements;
  }
  // from RunModelParams interface
  getOutputIndices() {
    return this.outputIndices.view;
  }
  // from RunModelParams interface
  copyOutputIndices(array, create) {
    if (this.outputIndices.lengthInElements === 0) {
      return;
    }
    if (array === void 0 || array.length < this.outputIndices.lengthInElements) {
      array = create(this.outputIndices.lengthInElements);
    }
    array.set(this.outputIndices.view);
  }
  // from RunModelParams interface
  getOutputsLength() {
    return this.outputs.lengthInElements;
  }
  // from RunModelParams interface
  getOutputs() {
    return this.outputs.view;
  }
  // from RunModelParams interface
  getOutputsObject() {
    return void 0;
  }
  // from RunModelParams interface
  storeOutputs(array) {
    if (this.outputs.view === void 0) {
      return;
    }
    if (array.length > this.outputs.view.length) {
      this.outputs.view.set(array.subarray(0, this.outputs.view.length));
    } else {
      this.outputs.view.set(array);
    }
  }
  // from RunModelParams interface
  getLookups() {
    if (this.lookupIndices.lengthInElements === 0) {
      return void 0;
    }
    return decodeLookups(this.lookupIndices.view, this.lookups.view);
  }
  // from RunModelParams interface
  getElapsedTime() {
    return this.extras.view[0];
  }
  // from RunModelParams interface
  storeElapsedTime(elapsed) {
    this.extras.view[0] = elapsed;
  }
  /**
   * Copy the outputs buffer to the given `Outputs` instance.  This should be called
   * after the `runModel` call has completed so that the output values are copied from
   * the internal buffer to the `Outputs` instance that was passed to `runModel`.
   *
   * @param outputs The `Outputs` instance into which the output values will be copied.
   */
  finalizeOutputs(outputs) {
    if (this.outputs.view) {
      outputs.updateFromBuffer(this.outputs.view, outputs.seriesLength);
    }
    outputs.runTimeInMillis = this.getElapsedTime();
  }
  /**
   * Update this instance using the parameters that are passed to a `runModel` call.
   *
   * @param inputs The model input values (must be in the same order as in the spec file).
   * @param outputs The structure into which the model outputs will be stored.
   * @param options Additional options that influence the model run.
   */
  updateFromParams(inputs, outputs, options) {
    const inputsLengthInElements = inputs.length;
    const outputsLengthInElements = outputs.varIds.length * outputs.seriesLength;
    let outputIndicesLengthInElements;
    const outputVarSpecs = outputs.varSpecs;
    if (outputVarSpecs !== void 0 && outputVarSpecs.length > 0) {
      outputIndicesLengthInElements = getEncodedVarIndicesLength(outputVarSpecs);
    } else {
      outputIndicesLengthInElements = 0;
    }
    let lookupsLengthInElements;
    let lookupIndicesLengthInElements;
    if ((options == null ? void 0 : options.lookups) !== void 0 && options.lookups.length > 0) {
      for (const lookupDef of options.lookups) {
        resolveVarRef(this.listing, lookupDef.varRef, "lookup");
      }
      const encodedLengths = getEncodedLookupBufferLengths(options.lookups);
      lookupsLengthInElements = encodedLengths.lookupsLength;
      lookupIndicesLengthInElements = encodedLengths.lookupIndicesLength;
    } else {
      lookupsLengthInElements = 0;
      lookupIndicesLengthInElements = 0;
    }
    let byteOffset = 0;
    function section(kind, lengthInElements) {
      const sectionOffsetInBytes = byteOffset;
      const bytesPerElement = kind === "float64" ? Float64Array.BYTES_PER_ELEMENT : Int32Array.BYTES_PER_ELEMENT;
      const requiredSectionLengthInBytes = Math.round(lengthInElements * bytesPerElement);
      const alignedSectionLengthInBytes = Math.ceil(requiredSectionLengthInBytes / 8) * 8;
      byteOffset += alignedSectionLengthInBytes;
      return sectionOffsetInBytes;
    }
    const headerOffsetInBytes = section("int32", headerLengthInElements);
    const extrasOffsetInBytes = section("float64", extrasLengthInElements);
    const inputsOffsetInBytes = section("float64", inputsLengthInElements);
    const outputsOffsetInBytes = section("float64", outputsLengthInElements);
    const outputIndicesOffsetInBytes = section("int32", outputIndicesLengthInElements);
    const lookupsOffsetInBytes = section("float64", lookupsLengthInElements);
    const lookupIndicesOffsetInBytes = section("int32", lookupIndicesLengthInElements);
    const requiredLengthInBytes = byteOffset;
    if (this.encoded === void 0 || this.encoded.byteLength < requiredLengthInBytes) {
      const totalLengthInBytes = Math.ceil(requiredLengthInBytes * 1.2);
      this.encoded = new ArrayBuffer(totalLengthInBytes);
      this.header.update(this.encoded, headerOffsetInBytes, headerLengthInElements);
    }
    const headerView = this.header.view;
    let headerIndex = 0;
    headerView[headerIndex++] = extrasOffsetInBytes;
    headerView[headerIndex++] = extrasLengthInElements;
    headerView[headerIndex++] = inputsOffsetInBytes;
    headerView[headerIndex++] = inputsLengthInElements;
    headerView[headerIndex++] = outputsOffsetInBytes;
    headerView[headerIndex++] = outputsLengthInElements;
    headerView[headerIndex++] = outputIndicesOffsetInBytes;
    headerView[headerIndex++] = outputIndicesLengthInElements;
    headerView[headerIndex++] = lookupsOffsetInBytes;
    headerView[headerIndex++] = lookupsLengthInElements;
    headerView[headerIndex++] = lookupIndicesOffsetInBytes;
    headerView[headerIndex++] = lookupIndicesLengthInElements;
    this.inputs.update(this.encoded, inputsOffsetInBytes, inputsLengthInElements);
    this.extras.update(this.encoded, extrasOffsetInBytes, extrasLengthInElements);
    this.outputs.update(this.encoded, outputsOffsetInBytes, outputsLengthInElements);
    this.outputIndices.update(this.encoded, outputIndicesOffsetInBytes, outputIndicesLengthInElements);
    this.lookups.update(this.encoded, lookupsOffsetInBytes, lookupsLengthInElements);
    this.lookupIndices.update(this.encoded, lookupIndicesOffsetInBytes, lookupIndicesLengthInElements);
    const inputsView = this.inputs.view;
    for (let i = 0; i < inputs.length; i++) {
      const input = inputs[i];
      if (typeof input === "number") {
        inputsView[i] = input;
      } else {
        inputsView[i] = input.get();
      }
    }
    if (this.outputIndices.view) {
      encodeVarIndices(outputVarSpecs, this.outputIndices.view);
    }
    if (lookupIndicesLengthInElements > 0) {
      encodeLookups(options.lookups, this.lookupIndices.view, this.lookups.view);
    }
  }
  /**
   * Update this instance using the values contained in the encoded buffer from another
   * `BufferedRunModelParams` instance.
   *
   * @param buffer An encoded buffer returned by `getEncodedBuffer`.
   */
  updateFromEncodedBuffer(buffer) {
    const headerLengthInBytes = headerLengthInElements * Int32Array.BYTES_PER_ELEMENT;
    if (buffer.byteLength < headerLengthInBytes) {
      throw new Error("Buffer must be long enough to contain header section");
    }
    this.encoded = buffer;
    const headerOffsetInBytes = 0;
    this.header.update(this.encoded, headerOffsetInBytes, headerLengthInElements);
    const headerView = this.header.view;
    let headerIndex = 0;
    const extrasOffsetInBytes = headerView[headerIndex++];
    const extrasLengthInElements2 = headerView[headerIndex++];
    const inputsOffsetInBytes = headerView[headerIndex++];
    const inputsLengthInElements = headerView[headerIndex++];
    const outputsOffsetInBytes = headerView[headerIndex++];
    const outputsLengthInElements = headerView[headerIndex++];
    const outputIndicesOffsetInBytes = headerView[headerIndex++];
    const outputIndicesLengthInElements = headerView[headerIndex++];
    const lookupsOffsetInBytes = headerView[headerIndex++];
    const lookupsLengthInElements = headerView[headerIndex++];
    const lookupIndicesOffsetInBytes = headerView[headerIndex++];
    const lookupIndicesLengthInElements = headerView[headerIndex++];
    const extrasLengthInBytes = extrasLengthInElements2 * Float64Array.BYTES_PER_ELEMENT;
    const inputsLengthInBytes = inputsLengthInElements * Float64Array.BYTES_PER_ELEMENT;
    const outputsLengthInBytes = outputsLengthInElements * Float64Array.BYTES_PER_ELEMENT;
    const outputIndicesLengthInBytes = outputIndicesLengthInElements * Int32Array.BYTES_PER_ELEMENT;
    const lookupsLengthInBytes = lookupsLengthInElements * Float64Array.BYTES_PER_ELEMENT;
    const lookupIndicesLengthInBytes = lookupIndicesLengthInElements * Int32Array.BYTES_PER_ELEMENT;
    const requiredLengthInBytes = headerLengthInBytes + extrasLengthInBytes + inputsLengthInBytes + outputsLengthInBytes + outputIndicesLengthInBytes + lookupsLengthInBytes + lookupIndicesLengthInBytes;
    if (buffer.byteLength < requiredLengthInBytes) {
      throw new Error("Buffer must be long enough to contain sections declared in header");
    }
    this.extras.update(this.encoded, extrasOffsetInBytes, extrasLengthInElements2);
    this.inputs.update(this.encoded, inputsOffsetInBytes, inputsLengthInElements);
    this.outputs.update(this.encoded, outputsOffsetInBytes, outputsLengthInElements);
    this.outputIndices.update(this.encoded, outputIndicesOffsetInBytes, outputIndicesLengthInElements);
    this.lookups.update(this.encoded, lookupsOffsetInBytes, lookupsLengthInElements);
    this.lookupIndices.update(this.encoded, lookupIndicesOffsetInBytes, lookupIndicesLengthInElements);
  }
};

// src/runnable-model/referenced-run-model-params.ts
var ReferencedRunModelParams = class {
  /**
   * @param listing The model listing that is used to locate a variable that is referenced by
   * name or identifier.  If undefined, variables cannot be referenced by name or identifier,
   * and can only be referenced using a valid `VarSpec`.
   */
  constructor(listing) {
    this.listing = listing;
    this.outputsLengthInElements = 0;
    this.outputIndicesLengthInElements = 0;
  }
  // from RunModelParams interface
  getInputs() {
    return void 0;
  }
  // from RunModelParams interface
  copyInputs(array, create) {
    const inputsLengthInElements = this.inputs.length;
    if (array === void 0 || array.length < inputsLengthInElements) {
      array = create(inputsLengthInElements);
    }
    for (let i = 0; i < this.inputs.length; i++) {
      const input = this.inputs[i];
      if (typeof input === "number") {
        array[i] = input;
      } else {
        array[i] = input.get();
      }
    }
  }
  // from RunModelParams interface
  getOutputIndicesLength() {
    return this.outputIndicesLengthInElements;
  }
  // from RunModelParams interface
  getOutputIndices() {
    return void 0;
  }
  // from RunModelParams interface
  copyOutputIndices(array, create) {
    if (this.outputIndicesLengthInElements === 0) {
      return;
    }
    if (array === void 0 || array.length < this.outputIndicesLengthInElements) {
      array = create(this.outputIndicesLengthInElements);
    }
    encodeVarIndices(this.outputs.varSpecs, array);
  }
  // from RunModelParams interface
  getOutputsLength() {
    return this.outputsLengthInElements;
  }
  // from RunModelParams interface
  getOutputs() {
    return void 0;
  }
  // from RunModelParams interface
  getOutputsObject() {
    return this.outputs;
  }
  // from RunModelParams interface
  storeOutputs(array) {
    if (this.outputs) {
      const result = this.outputs.updateFromBuffer(array, this.outputs.seriesLength);
      if (result.isErr()) {
        throw new Error(`Failed to store outputs: ${result.error}`);
      }
    }
  }
  // from RunModelParams interface
  getLookups() {
    if (this.lookups !== void 0 && this.lookups.length > 0) {
      return this.lookups;
    } else {
      return void 0;
    }
  }
  // from RunModelParams interface
  getElapsedTime() {
    var _a;
    return (_a = this.outputs) == null ? void 0 : _a.runTimeInMillis;
  }
  // from RunModelParams interface
  storeElapsedTime(elapsed) {
    if (this.outputs) {
      this.outputs.runTimeInMillis = elapsed;
    }
  }
  /**
   * Update this instance using the parameters that are passed to a `runModel` call.
   *
   * @param inputs The model input values (must be in the same order as in the spec file).
   * @param outputs The structure into which the model outputs will be stored.
   * @param options Additional options that influence the model run.
   */
  updateFromParams(inputs, outputs, options) {
    this.inputs = inputs;
    this.outputs = outputs;
    this.outputsLengthInElements = outputs.varIds.length * outputs.seriesLength;
    this.lookups = options == null ? void 0 : options.lookups;
    if (this.lookups) {
      for (const lookupDef of this.lookups) {
        resolveVarRef(this.listing, lookupDef.varRef, "lookup");
      }
    }
    const outputVarSpecs = outputs.varSpecs;
    if (outputVarSpecs !== void 0 && outputVarSpecs.length > 0) {
      this.outputIndicesLengthInElements = getEncodedVarIndicesLength(outputVarSpecs);
    } else {
      this.outputIndicesLengthInElements = 0;
    }
  }
};

// src/js-model/js-model-constants.ts
var _NA_ = -Number.MAX_VALUE;

// src/js-model/js-model-lookup.ts
var JsModelLookup = class {
  /**
   * @param n The number of (x,y) pairs in the lookup.
   * @param data The lookup data, as (x,y) pairs.  The length of the array must be
   * >= 2*n.  Note that the data will be stored by reference, so if there is a chance
   * that the array will be reused or modified by other code, be sure to pass in a
   * copy of the array.
   */
  constructor(n, data) {
    this.n = n;
    this.data = data;
    if (data.length < n * 2) {
      throw new Error(`Lookup data array length must be >= 2*size (length=${data.length} size=${n}`);
    }
    this.lastInput = Number.MAX_VALUE;
    this.lastHitIndex = 0;
  }
  getValueForX(x, mode) {
    return this.getValue(x, false, mode);
  }
  getValueForY(y) {
    if (this.invertedData === void 0) {
      const numValues = this.n * 2;
      const normalData = this.data;
      const invertedData = Array(numValues);
      for (let i = 0; i < numValues; i += 2) {
        invertedData[i] = normalData[i + 1];
        invertedData[i + 1] = normalData[i];
      }
      this.invertedData = invertedData;
    }
    return this.getValue(y, true, "interpolate");
  }
  /**
   * Interpolate the y value from the array of (x,y) pairs.
   * NOTE: The x values are assumed to be monotonically increasing.
   */
  getValue(input, useInvertedData, mode) {
    if (this.n === 0) {
      return _NA_;
    }
    const data = useInvertedData ? this.invertedData : this.data;
    const max = this.n * 2;
    const useCachedValues = !useInvertedData;
    let startIndex;
    if (useCachedValues && input >= this.lastInput) {
      startIndex = this.lastHitIndex;
    } else {
      startIndex = 0;
    }
    for (let xi = startIndex; xi < max; xi += 2) {
      const x = data[xi];
      if (x >= input) {
        if (useCachedValues) {
          this.lastInput = input;
          this.lastHitIndex = xi;
        }
        if (xi === 0 || x === input) {
          return data[xi + 1];
        }
        switch (mode) {
          default:
          case "interpolate": {
            const last_x = data[xi - 2];
            const last_y = data[xi - 1];
            const y = data[xi + 1];
            const dx = x - last_x;
            const dy = y - last_y;
            return last_y + dy / dx * (input - last_x);
          }
          case "forward":
            return data[xi + 1];
          case "backward":
            return data[xi - 1];
        }
      }
    }
    if (useCachedValues) {
      this.lastInput = input;
      this.lastHitIndex = max;
    }
    return data[max - 1];
  }
  /**
   * Return the most appropriate y value from the array of (x,y) pairs when
   * this instance is used to provide inputs for the `GAME` function.
   *
   * NOTE: The x values are assumed to be monotonically increasing.
   *
   * This method is similar to `getValueForX` in concept, except that this one
   * returns the provided `defaultValue` if the `time` parameter is earlier than
   * the first data point in the lookup.  Also, this method always uses the
   * `backward` interpolation mode, meaning that it holds the "current" value
   * constant instead of interpolating.
   *
   * @param time The time that is used to select the data point that has an
   * `x` value less than or equal to the provided time.
   * @param defaultValue The value that is returned if this lookup is empty (has
   * no points) or if the provided time is earlier than the first data point.
   */
  getValueForGameTime(time, defaultValue) {
    if (this.n <= 0) {
      return defaultValue;
    }
    const x0 = this.data[0];
    if (time < x0) {
      return defaultValue;
    }
    return this.getValue(time, false, "backward");
  }
  /**
   * Interpolate the y value from the array of (x,y) pairs.
   * NOTE: The x values are assumed to be monotonically increasing.
   *
   * This method is similar to `getValue` in concept, but Vensim produces results for
   * the `GET DATA BETWEEN TIMES` function that differ in unexpected ways from normal
   * lookup behavior, so we implement it as a separate method here.
   */
  getValueBetweenTimes(input, mode) {
    if (this.n === 0) {
      return _NA_;
    }
    const max = this.n * 2;
    switch (mode) {
      case "forward": {
        input = Math.floor(input);
        for (let xi = 0; xi < max; xi += 2) {
          const x = this.data[xi];
          if (x >= input) {
            return this.data[xi + 1];
          }
        }
        return this.data[max - 1];
      }
      case "backward": {
        input = Math.floor(input);
        for (let xi = 2; xi < max; xi += 2) {
          const x = this.data[xi];
          if (x >= input) {
            return this.data[xi - 1];
          }
        }
        if (max >= 4) {
          return this.data[max - 3];
        } else {
          return this.data[1];
        }
      }
      case "interpolate":
      default: {
        if (input - Math.floor(input) > 0) {
          let msg = `GET DATA BETWEEN TIMES was called with an input value (${input}) that has a fractional part. `;
          msg += "When mode is 0 (interpolate) and the input value is not a whole number, Vensim produces unexpected ";
          msg += "results that may differ from those produced by SDEverywhere.";
          throw new Error(msg);
        }
        for (let xi = 2; xi < max; xi += 2) {
          const x = this.data[xi];
          if (x >= input) {
            const last_x = this.data[xi - 2];
            const last_y = this.data[xi - 1];
            const y = this.data[xi + 1];
            const dx = x - last_x;
            const dy = y - last_y;
            return last_y + dy / dx * (input - last_x);
          }
        }
        return this.data[max - 1];
      }
    }
  }
};

// src/js-model/js-model-functions.ts
var EPSILON = 1e-6;
function getJsModelFunctions() {
  let ctx;
  const cachedVectors = /* @__PURE__ */ new Map();
  const cachedSortVectors = /* @__PURE__ */ new Map();
  return {
    setContext(context) {
      ctx = context;
    },
    ABS(x) {
      return Math.abs(x);
    },
    ARCCOS(x) {
      return Math.acos(x);
    },
    ARCSIN(x) {
      return Math.asin(x);
    },
    ARCTAN(x) {
      return Math.atan(x);
    },
    COS(x) {
      return Math.cos(x);
    },
    EXP(x) {
      return Math.exp(x);
    },
    GAME(inputs, x) {
      return inputs ? inputs.getValueForGameTime(ctx.currentTime, x) : x;
    },
    // GAMMA_LN(): number {
    //   throw new Error('GAMMA_LN function not yet implemented for JS target')
    // },
    INTEG(value, rate) {
      return value + rate * ctx.timeStep;
    },
    INTEGER(x) {
      return Math.trunc(x);
    },
    LN(x) {
      return Math.log(x);
    },
    MAX(x, y) {
      return Math.max(x, y);
    },
    MIN(x, y) {
      return Math.min(x, y);
    },
    MODULO(x, y) {
      return x % y;
    },
    POW(x, y) {
      return Math.pow(x, y);
    },
    POWER(x, y) {
      return Math.pow(x, y);
    },
    PULSE(start, width) {
      return pulse(ctx, start, width);
    },
    PULSE_TRAIN(start, width, interval, end) {
      const n = Math.floor((end - start) / interval);
      for (let k = 0; k <= n; k++) {
        if (ctx.currentTime <= end && pulse(ctx, start + k * interval, width)) {
          return 1;
        }
      }
      return 0;
    },
    QUANTUM(x, y) {
      return y <= 0 ? x : y * Math.trunc(x / y);
    },
    RAMP(slope, startTime, endTime) {
      if (ctx.currentTime > startTime) {
        if (ctx.currentTime < endTime || startTime > endTime) {
          return slope * (ctx.currentTime - startTime);
        } else {
          return slope * (endTime - startTime);
        }
      } else {
        return 0;
      }
    },
    SIN(x) {
      return Math.sin(x);
    },
    SQRT(x) {
      return Math.sqrt(x);
    },
    STEP(height, stepTime) {
      return ctx.currentTime + ctx.timeStep / 2 > stepTime ? height : 0;
    },
    TAN(x) {
      return Math.tan(x);
    },
    VECTOR_SORT_ORDER(vector, size, direction) {
      if (size > vector.length) {
        throw new Error(`VECTOR SORT ORDER input vector length (${vector.length}) must be >= size (${size})`);
      }
      let sortVector = cachedSortVectors.get(size);
      if (sortVector === void 0) {
        sortVector = Array(size);
        for (let i = 0; i < size; i++) {
          sortVector[i] = { x: 0, ind: 0 };
        }
        cachedSortVectors.set(size, sortVector);
      }
      let outArray = cachedVectors.get(size);
      if (outArray === void 0) {
        outArray = Array(size);
        cachedVectors.set(size, outArray);
      }
      for (let i = 0; i < size; i++) {
        sortVector[i].x = vector[i];
        sortVector[i].ind = i;
      }
      const sortOrder = direction > 0 ? 1 : -1;
      sortVector.sort((a, b) => {
        let result;
        if (a.x < b.x) {
          result = -1;
        } else if (a.x > b.x) {
          result = 1;
        } else {
          result = 0;
        }
        return result * sortOrder;
      });
      for (let i = 0; i < size; i++) {
        outArray[i] = sortVector[i].ind;
      }
      return outArray;
    },
    XIDZ(a, b, x) {
      return Math.abs(b) < EPSILON ? x : a / b;
    },
    ZIDZ(a, b) {
      if (Math.abs(b) < EPSILON) {
        return 0;
      } else {
        return a / b;
      }
    },
    //
    // Lookup functions
    //
    createLookup(size, data) {
      return new JsModelLookup(size, data);
    },
    LOOKUP(lookup, x) {
      return lookup ? lookup.getValueForX(x, "interpolate") : _NA_;
    },
    LOOKUP_FORWARD(lookup, x) {
      return lookup ? lookup.getValueForX(x, "forward") : _NA_;
    },
    LOOKUP_BACKWARD(lookup, x) {
      return lookup ? lookup.getValueForX(x, "backward") : _NA_;
    },
    LOOKUP_INVERT(lookup, y) {
      return lookup ? lookup.getValueForY(y) : _NA_;
    },
    WITH_LOOKUP(x, lookup) {
      return lookup ? lookup.getValueForX(x, "interpolate") : _NA_;
    },
    GET_DATA_BETWEEN_TIMES(lookup, x, mode) {
      let lookupMode;
      if (mode >= 1) {
        lookupMode = "forward";
      } else if (mode <= -1) {
        lookupMode = "backward";
      } else {
        lookupMode = "interpolate";
      }
      return lookup ? lookup.getValueBetweenTimes(x, lookupMode) : _NA_;
    }
  };
}
function pulse(ctx, start, width) {
  const timePlus = ctx.currentTime + ctx.timeStep / 2;
  if (width === 0) {
    width = ctx.timeStep;
  }
  return timePlus > start && timePlus < start + width ? 1 : 0;
}

// src/perf/perf.ts
var isWeb;
function perfNow() {
  if (isWeb === void 0) {
    isWeb = typeof self !== "undefined" && (self == null ? void 0 : self.performance) !== void 0;
  }
  if (isWeb) {
    return self.performance.now();
  } else {
    return process == null ? void 0 : process.hrtime();
  }
}
function perfElapsed(t0) {
  if (isWeb) {
    const t1 = self.performance.now();
    return t1 - t0;
  } else {
    const elapsed = process.hrtime(t0);
    return (elapsed[0] * 1e9 + elapsed[1]) / 1e6;
  }
}

// src/runnable-model/base-runnable-model.ts
var BaseRunnableModel = class {
  constructor(options) {
    this.startTime = options.startTime;
    this.endTime = options.endTime;
    this.saveFreq = options.saveFreq;
    this.numSavePoints = options.numSavePoints;
    this.outputVarIds = options.outputVarIds;
    this.modelListing = options.modelListing;
    this.onRunModel = options.onRunModel;
  }
  // from RunnableModel interface
  runModel(params) {
    var _a;
    let inputsArray = params.getInputs();
    if (inputsArray === void 0) {
      params.copyInputs(this.inputs, (numElements) => {
        this.inputs = new Float64Array(numElements);
        return this.inputs;
      });
      inputsArray = this.inputs;
    }
    let outputIndicesArray = params.getOutputIndices();
    if (outputIndicesArray === void 0 && params.getOutputIndicesLength() > 0) {
      params.copyOutputIndices(this.outputIndices, (numElements) => {
        this.outputIndices = new Int32Array(numElements);
        return this.outputIndices;
      });
      outputIndicesArray = this.outputIndices;
    }
    const outputsLengthInElements = params.getOutputsLength();
    if (this.outputs === void 0 || this.outputs.length < outputsLengthInElements) {
      this.outputs = new Float64Array(outputsLengthInElements);
    }
    const outputsArray = this.outputs;
    const t0 = perfNow();
    (_a = this.onRunModel) == null ? void 0 : _a.call(this, inputsArray, outputsArray, {
      outputIndices: outputIndicesArray,
      lookups: params.getLookups()
    });
    const elapsed = perfElapsed(t0);
    params.storeOutputs(outputsArray);
    params.storeElapsedTime(elapsed);
  }
  // from RunnableModel interface
  terminate() {
  }
};

// src/js-model/js-model.ts
function initJsModel(model) {
  let fns = model.getModelFunctions();
  if (fns === void 0) {
    fns = getJsModelFunctions();
    model.setModelFunctions(fns);
  }
  const initialTime = model.getInitialTime();
  const finalTime = model.getFinalTime();
  const timeStep = model.getTimeStep();
  const saveFreq = model.getSaveFreq();
  const numSavePoints = Math.round((finalTime - initialTime) / saveFreq) + 1;
  return new BaseRunnableModel({
    startTime: initialTime,
    endTime: finalTime,
    saveFreq,
    numSavePoints,
    outputVarIds: model.outputVarIds,
    modelListing: model.modelListing,
    onRunModel: (inputs, outputs, options) => {
      runJsModel(
        model,
        initialTime,
        finalTime,
        timeStep,
        saveFreq,
        numSavePoints,
        inputs,
        outputs,
        options == null ? void 0 : options.outputIndices,
        options == null ? void 0 : options.lookups,
        void 0
      );
    }
  });
}
function runJsModel(model, initialTime, finalTime, timeStep, saveFreq, numSavePoints, inputs, outputs, outputIndices, lookups, stopAfterTime) {
  let time = initialTime;
  model.setTime(time);
  const fnContext = {
    timeStep,
    currentTime: time
  };
  model.getModelFunctions().setContext(fnContext);
  model.initConstants();
  if (lookups !== void 0) {
    for (const lookupDef of lookups) {
      model.setLookup(lookupDef.varRef.varSpec, lookupDef.points);
    }
  }
  if ((inputs == null ? void 0 : inputs.length) > 0) {
    model.setInputs((index) => inputs[index]);
  }
  model.initLevels();
  const lastStep = Math.round((finalTime - initialTime) / timeStep);
  const stopTime = stopAfterTime !== void 0 ? stopAfterTime : finalTime;
  let step = 0;
  let savePointIndex = 0;
  let outputVarIndex = 0;
  while (step <= lastStep) {
    model.evalAux();
    if (time % saveFreq < 1e-6) {
      outputVarIndex = 0;
      const storeValue = (value) => {
        const outputBufferIndex = outputVarIndex * numSavePoints + savePointIndex;
        outputs[outputBufferIndex] = time <= stopTime ? value : void 0;
        outputVarIndex++;
      };
      if (outputIndices !== void 0) {
        let indexBufferOffset = 0;
        const outputCount = outputIndices[indexBufferOffset++];
        for (let i = 0; i < outputCount; i++) {
          const varIndex = outputIndices[indexBufferOffset++];
          const subCount = outputIndices[indexBufferOffset++];
          let subscriptIndices;
          if (subCount > 0) {
            subscriptIndices = outputIndices.subarray(indexBufferOffset, indexBufferOffset + subCount);
            indexBufferOffset += subCount;
          }
          const varSpec = {
            varIndex,
            subscriptIndices
          };
          model.storeOutput(varSpec, storeValue);
        }
      } else {
        model.storeOutputs(storeValue);
      }
      savePointIndex++;
    }
    if (step === lastStep) {
      break;
    }
    model.evalLevels();
    time += timeStep;
    model.setTime(time);
    fnContext.currentTime = time;
    step++;
  }
}

// src/js-model/exec-js-model.ts
function execJsModel(jsModel) {
  const runnableModel = initJsModel(jsModel);
  const inputs = [];
  const outputVarIds = jsModel.outputVarIds;
  const startTime = jsModel.getInitialTime();
  const endTime = jsModel.getFinalTime();
  const saveFreq = jsModel.getSaveFreq();
  const outputs = new Outputs(outputVarIds, startTime, endTime, saveFreq);
  const params = new ReferencedRunModelParams();
  params.updateFromParams(inputs, outputs);
  runnableModel.runModel(params);
  const outputVarNames = jsModel.outputVarNames.map((name) => name.replace(/"/g, '\\"'));
  const header = outputVarNames.join("	");
  console.log(header);
  for (let i = 0; i < outputs.seriesLength; i++) {
    const rowValues = [];
    for (const series of outputs.varSeries) {
      rowValues.push(series.points[i].y);
    }
    console.log(rowValues.join("	"));
  }
}

// src/js-model/_mocks/mock-js-model.ts
var MockJsModel = class {
  constructor(options) {
    // from JsModel interface
    this.kind = "js";
    this.vars = /* @__PURE__ */ new Map();
    this.lookups = /* @__PURE__ */ new Map();
    this.outputVarIds = options.outputVarIds;
    this.outputVarNames = options.outputVarIds;
    this.initialTime = options.initialTime;
    this.finalTime = options.finalTime;
    this.outputVarIds = options.outputVarIds;
    if (options.listingJson) {
      this.modelListing = JSON.parse(options.listingJson);
      this.internalListing = new ModelListing(this.modelListing);
    }
    this.onEvalAux = options.onEvalAux;
  }
  varIdForSpec(varSpec) {
    for (const [listingVarId, listingSpec] of this.internalListing.varSpecs) {
      if (listingSpec.varIndex === varSpec.varIndex) {
        return listingVarId;
      }
    }
    return void 0;
  }
  // from JsModel interface
  getInitialTime() {
    return this.initialTime;
  }
  // from JsModel interface
  getFinalTime() {
    return this.finalTime;
  }
  // from JsModel interface
  getTimeStep() {
    return 1;
  }
  // from JsModel interface
  getSaveFreq() {
    return 1;
  }
  // from JsModel interface
  getModelFunctions() {
    return this.fns;
  }
  // from JsModel interface
  setModelFunctions(fns) {
    this.fns = fns;
  }
  // from JsModel interface
  setTime(time) {
    this.vars.set("_time", time);
  }
  // from JsModel interface
  setInputs() {
  }
  // from JsModel interface
  setLookup(varSpec, points) {
    const varId = this.varIdForSpec(varSpec);
    if (varId === void 0) {
      throw new Error(`No lookup variable found for spec ${varSpec}`);
    }
    this.lookups.set(varId, new JsModelLookup(points.length / 2, points));
  }
  // from JsModel interface
  storeOutputs(storeValue) {
    for (const varId of this.outputVarIds) {
      storeValue(this.vars.get(varId));
    }
  }
  // from JsModel interface
  storeOutput(varSpec, storeValue) {
    const varId = this.varIdForSpec(varSpec);
    if (varId === void 0) {
      throw new Error(`No output variable found for spec ${varSpec}`);
    }
    storeValue(this.vars.get(varId));
  }
  // from JsModel interface
  initConstants() {
  }
  // from JsModel interface
  initLevels() {
  }
  // from JsModel interface
  evalAux() {
    var _a;
    (_a = this.onEvalAux) == null ? void 0 : _a.call(this, this.vars, this.lookups);
  }
  // from JsModel interface
  evalLevels() {
  }
};

// src/wasm-model/wasm-buffer.ts
var WasmBuffer = class {
  /**
   * @param wasmModule The `WasmModule` used to initialize the memory.
   * @param numElements The number of elements in the buffer.
   * @param byteOffset The byte offset within the wasm heap.
   * @param heapArray The array view on the underlying heap buffer.
   */
  constructor(wasmModule, numElements, byteOffset, heapArray) {
    this.wasmModule = wasmModule;
    this.numElements = numElements;
    this.byteOffset = byteOffset;
    this.heapArray = heapArray;
  }
  /**
   * @return An `ArrType` view on the underlying heap buffer.
   */
  getArrayView() {
    return this.heapArray;
  }
  /**
   * @return The raw address of the underlying heap buffer.
   * @hidden This is intended for use by `WasmModel` only.
   */
  getAddress() {
    return this.byteOffset;
  }
  /**
   * Dispose the buffer by freeing the allocated heap memory.
   */
  dispose() {
    var _a, _b;
    if (this.heapArray) {
      (_b = (_a = this.wasmModule)._free) == null ? void 0 : _b.call(_a, this.byteOffset);
      this.numElements = void 0;
      this.heapArray = void 0;
      this.byteOffset = void 0;
    }
  }
};
function createInt32WasmBuffer(wasmModule, numElements) {
  const elemSizeInBytes = 4;
  const lengthInBytes = numElements * elemSizeInBytes;
  const byteOffset = wasmModule._malloc(lengthInBytes);
  const elemOffset = byteOffset / elemSizeInBytes;
  const heapArray = wasmModule.HEAP32.subarray(elemOffset, elemOffset + numElements);
  return new WasmBuffer(wasmModule, numElements, byteOffset, heapArray);
}
function createFloat64WasmBuffer(wasmModule, numElements) {
  const elemSizeInBytes = 8;
  const lengthInBytes = numElements * elemSizeInBytes;
  const byteOffset = wasmModule._malloc(lengthInBytes);
  const elemOffset = byteOffset / elemSizeInBytes;
  const heapArray = wasmModule.HEAPF64.subarray(elemOffset, elemOffset + numElements);
  return new WasmBuffer(wasmModule, numElements, byteOffset, heapArray);
}

// src/wasm-model/wasm-model.ts
var WasmModel = class {
  /**
   * @param wasmModule The `WasmModule` that provides access to the native functions.
   * @param outputVarIds The output variable IDs for this model.
   */
  constructor(wasmModule) {
    this.wasmModule = wasmModule;
    function getNumberValue(funcName) {
      const wasmGetValue = wasmModule.cwrap(funcName, "number", []);
      return wasmGetValue();
    }
    this.startTime = getNumberValue("getInitialTime");
    this.endTime = getNumberValue("getFinalTime");
    this.saveFreq = getNumberValue("getSaveper");
    this.numSavePoints = Math.round((this.endTime - this.startTime) / this.saveFreq) + 1;
    this.outputVarIds = wasmModule.outputVarIds;
    this.modelListing = wasmModule.modelListing;
    this.wasmSetLookup = wasmModule.cwrap("setLookup", null, ["number", "number", "number", "number"]);
    this.wasmRunModel = wasmModule.cwrap("runModelWithBuffers", null, ["number", "number", "number"]);
  }
  // from RunnableModel interface
  runModel(params) {
    var _a, _b, _c, _d, _e, _f, _g;
    const lookups = params.getLookups();
    if (lookups !== void 0) {
      for (const lookupDef of lookups) {
        const varSpec = lookupDef.varRef.varSpec;
        const numSubElements = ((_a = varSpec.subscriptIndices) == null ? void 0 : _a.length) || 0;
        let subIndicesAddress;
        if (numSubElements > 0) {
          if (this.lookupSubIndicesBuffer === void 0 || this.lookupSubIndicesBuffer.numElements < numSubElements) {
            (_b = this.lookupSubIndicesBuffer) == null ? void 0 : _b.dispose();
            this.lookupSubIndicesBuffer = createInt32WasmBuffer(this.wasmModule, numSubElements);
          }
          this.lookupSubIndicesBuffer.getArrayView().set(varSpec.subscriptIndices);
          subIndicesAddress = this.lookupSubIndicesBuffer.getAddress();
        } else {
          subIndicesAddress = 0;
        }
        const numLookupElements = lookupDef.points.length;
        if (this.lookupDataBuffer === void 0 || this.lookupDataBuffer.numElements < numLookupElements) {
          (_c = this.lookupDataBuffer) == null ? void 0 : _c.dispose();
          this.lookupDataBuffer = createFloat64WasmBuffer(this.wasmModule, numLookupElements);
        }
        this.lookupDataBuffer.getArrayView().set(lookupDef.points);
        const pointsAddress = this.lookupDataBuffer.getAddress();
        const numPoints = numLookupElements / 2;
        const varIndex = varSpec.varIndex;
        this.wasmSetLookup(varIndex, subIndicesAddress, pointsAddress, numPoints);
      }
    }
    params.copyInputs((_d = this.inputsBuffer) == null ? void 0 : _d.getArrayView(), (numElements) => {
      var _a2;
      (_a2 = this.inputsBuffer) == null ? void 0 : _a2.dispose();
      this.inputsBuffer = createFloat64WasmBuffer(this.wasmModule, numElements);
      return this.inputsBuffer.getArrayView();
    });
    let outputIndicesBuffer;
    if (params.getOutputIndicesLength() > 0) {
      params.copyOutputIndices((_e = this.outputIndicesBuffer) == null ? void 0 : _e.getArrayView(), (numElements) => {
        var _a2;
        (_a2 = this.outputIndicesBuffer) == null ? void 0 : _a2.dispose();
        this.outputIndicesBuffer = createInt32WasmBuffer(this.wasmModule, numElements);
        return this.outputIndicesBuffer.getArrayView();
      });
      outputIndicesBuffer = this.outputIndicesBuffer;
    } else {
      outputIndicesBuffer = void 0;
    }
    const outputsLengthInElements = params.getOutputsLength();
    if (this.outputsBuffer === void 0 || this.outputsBuffer.numElements < outputsLengthInElements) {
      (_f = this.outputsBuffer) == null ? void 0 : _f.dispose();
      this.outputsBuffer = createFloat64WasmBuffer(this.wasmModule, outputsLengthInElements);
    }
    const t0 = perfNow();
    this.wasmRunModel(
      ((_g = this.inputsBuffer) == null ? void 0 : _g.getAddress()) || 0,
      this.outputsBuffer.getAddress(),
      (outputIndicesBuffer == null ? void 0 : outputIndicesBuffer.getAddress()) || 0
    );
    const elapsed = perfElapsed(t0);
    params.storeOutputs(this.outputsBuffer.getArrayView());
    params.storeElapsedTime(elapsed);
  }
  // from RunnableModel interface
  terminate() {
    var _a, _b, _c;
    (_a = this.inputsBuffer) == null ? void 0 : _a.dispose();
    this.inputsBuffer = void 0;
    (_b = this.outputsBuffer) == null ? void 0 : _b.dispose();
    this.outputsBuffer = void 0;
    (_c = this.outputIndicesBuffer) == null ? void 0 : _c.dispose();
    this.outputIndicesBuffer = void 0;
  }
};
function initWasmModel(wasmModule) {
  return new WasmModel(wasmModule);
}

// src/wasm-model/_mocks/mock-wasm-module.ts
var MockWasmModule = class {
  constructor(options) {
    // from WasmModule interface
    this.kind = "wasm";
    // Start at 8 so that we can treat 0 as NULL
    this.mallocOffset = 8;
    this.allocs = /* @__PURE__ */ new Map();
    this.lookups = /* @__PURE__ */ new Map();
    this.initialTime = options.initialTime;
    this.finalTime = options.finalTime;
    this.outputVarIds = options.outputVarIds;
    if (options.listingJson) {
      this.modelListing = JSON.parse(options.listingJson);
      this.internalListing = new ModelListing(this.modelListing);
    }
    this.onRunModel = options.onRunModel;
    this.heap = new ArrayBuffer(8192);
    this.HEAP32 = new Int32Array(this.heap);
    this.HEAPF64 = new Float64Array(this.heap);
  }
  varIdForSpec(varSpec) {
    for (const [listingVarId, listingSpec] of this.internalListing.varSpecs) {
      if (listingSpec.varIndex === varSpec.varIndex) {
        return listingVarId;
      }
    }
    return void 0;
  }
  // from WasmModule interface
  cwrap(fname) {
    switch (fname) {
      case "getInitialTime":
        return () => this.initialTime;
      case "getFinalTime":
        return () => this.finalTime;
      case "getSaveper":
        return () => 1;
      case "setLookup":
        return (varIndex, _subIndicesAddress, pointsAddress, numPoints) => {
          const varId = this.varIdForSpec({ varIndex });
          if (varId === void 0) {
            throw new Error(`No lookup variable found for var index ${varIndex}`);
          }
          const points = new Float64Array(this.getHeapView("float64", pointsAddress));
          this.lookups.set(varId, new JsModelLookup(numPoints, points));
        };
      case "runModelWithBuffers":
        return (inputsAddress, outputsAddress, outputIndicesAddress) => {
          const inputs = this.getHeapView("float64", inputsAddress);
          const outputs = this.getHeapView("float64", outputsAddress);
          const outputIndices = this.getHeapView("int32", outputIndicesAddress);
          this.onRunModel(inputs, outputs, this.lookups, outputIndices);
        };
      default:
        throw new Error(`Unhandled call to cwrap with function name '${fname}'`);
    }
  }
  // from WasmModule interface
  _malloc(lengthInBytes) {
    const currentOffset = this.mallocOffset;
    this.allocs.set(currentOffset, lengthInBytes);
    if (lengthInBytes > 0) {
      this.mallocOffset += lengthInBytes;
    } else {
      this.mallocOffset += 8;
    }
    return currentOffset;
  }
  // from WasmModule interface
  _free() {
  }
  getHeapView(kind, address) {
    if (address === 0) {
      return void 0;
    }
    const lengthInBytes = this.allocs.get(address);
    if (lengthInBytes === void 0) {
      throw new Error("Failed to locate heap allocation");
    }
    if (kind === "float64") {
      const offset = address / 8;
      return this.HEAPF64.subarray(offset, offset + lengthInBytes / 8);
    } else {
      const offset = address / 4;
      return this.HEAP32.subarray(offset, offset + lengthInBytes / 4);
    }
  }
};

// src/model-runner/synchronous-model-runner.ts
function createRunnableModel(generatedModel) {
  switch (generatedModel.kind) {
    case "js":
      return initJsModel(generatedModel);
    case "wasm":
      return initWasmModel(generatedModel);
    default:
      throw new Error(`Unable to identify generated model kind`);
  }
}
function createSynchronousModelRunner(generatedModel) {
  const runnableModel = createRunnableModel(generatedModel);
  return createRunnerFromRunnableModel(runnableModel);
}
function createRunnerFromRunnableModel(model) {
  const listing = model.modelListing ? new ModelListing(model.modelListing) : void 0;
  const params = new ReferencedRunModelParams(listing);
  let terminated = false;
  const runModelSync = (inputs, outputs, options) => {
    params.updateFromParams(inputs, outputs, options);
    model.runModel(params);
    return outputs;
  };
  return {
    createOutputs: () => {
      return new Outputs(model.outputVarIds, model.startTime, model.endTime, model.saveFreq);
    },
    runModel: (inputs, outputs, options) => {
      if (terminated) {
        return Promise.reject(new Error("Model runner has already been terminated"));
      }
      return Promise.resolve(runModelSync(inputs, outputs, options));
    },
    runModelSync: (inputs, outputs, options) => {
      if (terminated) {
        throw new Error("Model runner has already been terminated");
      }
      return runModelSync(inputs, outputs, options);
    },
    terminate: () => __async(this, null, function* () {
      if (!terminated) {
        model.terminate();
        terminated = true;
      }
    })
  };
}

// src/model-scheduler/model-scheduler.ts
var ModelScheduler = class {
  /**
   * @param runner The model runner.
   * @param userInputs The input values, in the same order as in the spec file passed to `sde`.
   * @param outputs The structure into which the model outputs will be stored.
   */
  constructor(runner, userInputs, outputs) {
    this.runner = runner;
    this.userInputs = userInputs;
    this.outputs = outputs;
    /** Whether a model run has been scheduled. */
    this.runNeeded = false;
    /** Whether a model run is in progress. */
    this.runInProgress = false;
    const afterSet = () => {
      this.runWasmModelIfNeeded();
    };
    for (const userInput of userInputs) {
      userInput.callbacks.onSet = afterSet;
    }
    this.currentInputs = [];
    for (const userInput of userInputs) {
      this.currentInputs.push(createSimpleInputValue(userInput.varId));
    }
  }
  /**
   * Schedule a wasm model run (if not already pending).  When the run is
   * complete, save the outputs and call the `onOutputsChanged` callback.
   */
  runWasmModelIfNeeded() {
    this.runNeeded = true;
    if (this.runInProgress) {
      return;
    } else {
      this.runInProgress = true;
      setTimeout(() => {
        this.runWasmModelNow();
      }, 0);
    }
  }
  /**
   * Run the wasm model asynchronously using the current set of input values.
   */
  runWasmModelNow() {
    return __async(this, null, function* () {
      var _a;
      for (let i = 0; i < this.userInputs.length; i++) {
        this.currentInputs[i].set(this.userInputs[i].get());
      }
      try {
        this.outputs = yield this.runner.runModel(this.currentInputs, this.outputs);
        (_a = this.onOutputsChanged) == null ? void 0 : _a.call(this, this.outputs);
      } catch (e) {
        console.error(`ERROR: Failed to run model: ${e.message}`);
      }
      if (this.runNeeded) {
        this.runNeeded = false;
        setTimeout(() => {
          this.runWasmModelNow();
        }, 0);
      } else {
        this.runNeeded = false;
        this.runInProgress = false;
      }
    });
  }
};
function createSimpleInputValue(varId) {
  let currentValue = 0;
  const get = () => {
    return currentValue;
  };
  const set = (newValue) => {
    currentValue = newValue;
  };
  const reset = () => {
    set(0);
  };
  return { varId, get, set, reset, callbacks: {} };
}
export {
  BufferedRunModelParams,
  MockJsModel,
  MockWasmModule,
  ModelListing,
  ModelScheduler,
  Outputs,
  ReferencedRunModelParams,
  Series,
  createInputValue,
  createLookupDef,
  createRunnableModel,
  createSynchronousModelRunner,
  decodeLookups,
  encodeLookups,
  encodeVarIndices,
  execJsModel,
  getEncodedLookupBufferLengths,
  getEncodedVarIndicesLength,
  getJsModelFunctions,
  initJsModel,
  initWasmModel,
  perfElapsed,
  perfNow
};
//# sourceMappingURL=index.js.map