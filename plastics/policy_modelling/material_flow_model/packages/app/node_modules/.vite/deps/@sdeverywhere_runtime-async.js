import {
  BufferedRunModelParams,
  ModelListing,
  Outputs,
  createRunnableModel
} from "./chunk-GAPZARQP.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  __toESM
} from "./chunk-PLDDJCW6.js";

// node_modules/threads/dist/serializers.js
var require_serializers = __commonJS({
  "node_modules/threads/dist/serializers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DefaultSerializer = exports.extendSerializer = void 0;
    function extendSerializer(extend, implementation) {
      const fallbackDeserializer = extend.deserialize.bind(extend);
      const fallbackSerializer = extend.serialize.bind(extend);
      return {
        deserialize(message) {
          return implementation.deserialize(message, fallbackDeserializer);
        },
        serialize(input) {
          return implementation.serialize(input, fallbackSerializer);
        }
      };
    }
    exports.extendSerializer = extendSerializer;
    var DefaultErrorSerializer = {
      deserialize(message) {
        return Object.assign(Error(message.message), {
          name: message.name,
          stack: message.stack
        });
      },
      serialize(error) {
        return {
          __error_marker: "$$error",
          message: error.message,
          name: error.name,
          stack: error.stack
        };
      }
    };
    var isSerializedError = (thing) => thing && typeof thing === "object" && "__error_marker" in thing && thing.__error_marker === "$$error";
    exports.DefaultSerializer = {
      deserialize(message) {
        if (isSerializedError(message)) {
          return DefaultErrorSerializer.deserialize(message);
        } else {
          return message;
        }
      },
      serialize(input) {
        if (input instanceof Error) {
          return DefaultErrorSerializer.serialize(input);
        } else {
          return input;
        }
      }
    };
  }
});

// node_modules/threads/dist/common.js
var require_common = __commonJS({
  "node_modules/threads/dist/common.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serialize = exports.deserialize = exports.registerSerializer = void 0;
    var serializers_1 = require_serializers();
    var registeredSerializer = serializers_1.DefaultSerializer;
    function registerSerializer3(serializer) {
      registeredSerializer = serializers_1.extendSerializer(registeredSerializer, serializer);
    }
    exports.registerSerializer = registerSerializer3;
    function deserialize(message) {
      return registeredSerializer.deserialize(message);
    }
    exports.deserialize = deserialize;
    function serialize(input) {
      return registeredSerializer.serialize(input);
    }
    exports.serialize = serialize;
  }
});

// node_modules/threads/dist/master/get-bundle-url.browser.js
var require_get_bundle_url_browser = __commonJS({
  "node_modules/threads/dist/master/get-bundle-url.browser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getBundleURL = exports.getBaseURL = void 0;
    var bundleURL;
    function getBundleURLCached() {
      if (!bundleURL) {
        bundleURL = getBundleURL();
      }
      return bundleURL;
    }
    exports.getBundleURL = getBundleURLCached;
    function getBundleURL() {
      try {
        throw new Error();
      } catch (err) {
        const matches = ("" + err.stack).match(/(https?|file|ftp|chrome-extension|moz-extension):\/\/[^)\n]+/g);
        if (matches) {
          return getBaseURL(matches[0]);
        }
      }
      return "/";
    }
    function getBaseURL(url) {
      return ("" + url).replace(/^((?:https?|file|ftp|chrome-extension|moz-extension):\/\/.+)?\/[^/]+(?:\?.*)?$/, "$1") + "/";
    }
    exports.getBaseURL = getBaseURL;
  }
});

// node_modules/threads/dist/master/implementation.browser.js
var require_implementation_browser = __commonJS({
  "node_modules/threads/dist/master/implementation.browser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isWorkerRuntime = exports.getWorkerImplementation = exports.defaultPoolSize = void 0;
    var get_bundle_url_browser_1 = require_get_bundle_url_browser();
    exports.defaultPoolSize = typeof navigator !== "undefined" && navigator.hardwareConcurrency ? navigator.hardwareConcurrency : 4;
    var isAbsoluteURL = (value) => /^[a-zA-Z][a-zA-Z\d+\-.]*:/.test(value);
    function createSourceBlobURL(code) {
      const blob = new Blob([code], { type: "application/javascript" });
      return URL.createObjectURL(blob);
    }
    function selectWorkerImplementation() {
      if (typeof Worker === "undefined") {
        return class NoWebWorker {
          constructor() {
            throw Error("No web worker implementation available. You might have tried to spawn a worker within a worker in a browser that doesn't support workers in workers.");
          }
        };
      }
      class WebWorker extends Worker {
        constructor(url, options) {
          var _a, _b;
          if (typeof url === "string" && options && options._baseURL) {
            url = new URL(url, options._baseURL);
          } else if (typeof url === "string" && !isAbsoluteURL(url) && get_bundle_url_browser_1.getBundleURL().match(/^file:\/\//i)) {
            url = new URL(url, get_bundle_url_browser_1.getBundleURL().replace(/\/[^\/]+$/, "/"));
            if ((_a = options === null || options === void 0 ? void 0 : options.CORSWorkaround) !== null && _a !== void 0 ? _a : true) {
              url = createSourceBlobURL(`importScripts(${JSON.stringify(url)});`);
            }
          }
          if (typeof url === "string" && isAbsoluteURL(url)) {
            if ((_b = options === null || options === void 0 ? void 0 : options.CORSWorkaround) !== null && _b !== void 0 ? _b : true) {
              url = createSourceBlobURL(`importScripts(${JSON.stringify(url)});`);
            }
          }
          super(url, options);
        }
      }
      class BlobWorker2 extends WebWorker {
        constructor(blob, options) {
          const url = window.URL.createObjectURL(blob);
          super(url, options);
        }
        static fromText(source, options) {
          const blob = new window.Blob([source], { type: "text/javascript" });
          return new BlobWorker2(blob, options);
        }
      }
      return {
        blob: BlobWorker2,
        default: WebWorker
      };
    }
    var implementation;
    function getWorkerImplementation() {
      if (!implementation) {
        implementation = selectWorkerImplementation();
      }
      return implementation;
    }
    exports.getWorkerImplementation = getWorkerImplementation;
    function isWorkerRuntime() {
      const isWindowContext = typeof self !== "undefined" && typeof Window !== "undefined" && self instanceof Window;
      return typeof self !== "undefined" && self.postMessage && !isWindowContext ? true : false;
    }
    exports.isWorkerRuntime = isWorkerRuntime;
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common2 = __commonJS({
  "node_modules/debug/src/common.js"(exports, module) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports, module) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = require_common2()(exports);
    var { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/observable-fns/dist.esm/_scheduler.js
var __awaiter, AsyncSerialScheduler;
var init_scheduler = __esm({
  "node_modules/observable-fns/dist.esm/_scheduler.js"() {
    __awaiter = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    AsyncSerialScheduler = class {
      constructor(observer) {
        this._baseObserver = observer;
        this._pendingPromises = /* @__PURE__ */ new Set();
      }
      complete() {
        Promise.all(this._pendingPromises).then(() => this._baseObserver.complete()).catch((error) => this._baseObserver.error(error));
      }
      error(error) {
        this._baseObserver.error(error);
      }
      schedule(task) {
        const prevPromisesCompletion = Promise.all(this._pendingPromises);
        const values = [];
        const next = (value) => values.push(value);
        const promise = Promise.resolve().then(() => __awaiter(this, void 0, void 0, function* () {
          yield prevPromisesCompletion;
          yield task(next);
          this._pendingPromises.delete(promise);
          for (const value of values) {
            this._baseObserver.next(value);
          }
        })).catch((error) => {
          this._pendingPromises.delete(promise);
          this._baseObserver.error(error);
        });
        this._pendingPromises.add(promise);
      }
    };
  }
});

// node_modules/observable-fns/dist.esm/symbols.js
var init_symbols = __esm({
  "node_modules/observable-fns/dist.esm/symbols.js"() {
  }
});

// node_modules/observable-fns/dist.esm/_symbols.js
var hasSymbols, hasSymbol, getSymbol;
var init_symbols2 = __esm({
  "node_modules/observable-fns/dist.esm/_symbols.js"() {
    hasSymbols = () => typeof Symbol === "function";
    hasSymbol = (name) => hasSymbols() && Boolean(Symbol[name]);
    getSymbol = (name) => hasSymbol(name) ? Symbol[name] : "@@" + name;
    if (!hasSymbol("asyncIterator")) {
      Symbol.asyncIterator = Symbol.asyncIterator || Symbol.for("Symbol.asyncIterator");
    }
  }
});

// node_modules/observable-fns/dist.esm/observable.js
function getMethod(obj, key) {
  const value = obj[key];
  if (value == null) {
    return void 0;
  }
  if (typeof value !== "function") {
    throw new TypeError(value + " is not a function");
  }
  return value;
}
function getSpecies(obj) {
  let ctor = obj.constructor;
  if (ctor !== void 0) {
    ctor = ctor[SymbolSpecies];
    if (ctor === null) {
      ctor = void 0;
    }
  }
  return ctor !== void 0 ? ctor : Observable;
}
function isObservable(x) {
  return x instanceof Observable;
}
function hostReportError(error) {
  if (hostReportError.log) {
    hostReportError.log(error);
  } else {
    setTimeout(() => {
      throw error;
    }, 0);
  }
}
function enqueue(fn) {
  Promise.resolve().then(() => {
    try {
      fn();
    } catch (e) {
      hostReportError(e);
    }
  });
}
function cleanupSubscription(subscription) {
  const cleanup = subscription._cleanup;
  if (cleanup === void 0) {
    return;
  }
  subscription._cleanup = void 0;
  if (!cleanup) {
    return;
  }
  try {
    if (typeof cleanup === "function") {
      cleanup();
    } else {
      const unsubscribe2 = getMethod(cleanup, "unsubscribe");
      if (unsubscribe2) {
        unsubscribe2.call(cleanup);
      }
    }
  } catch (e) {
    hostReportError(e);
  }
}
function closeSubscription(subscription) {
  subscription._observer = void 0;
  subscription._queue = void 0;
  subscription._state = "closed";
}
function flushSubscription(subscription) {
  const queue = subscription._queue;
  if (!queue) {
    return;
  }
  subscription._queue = void 0;
  subscription._state = "ready";
  for (const item of queue) {
    notifySubscription(subscription, item.type, item.value);
    if (subscription._state === "closed") {
      break;
    }
  }
}
function notifySubscription(subscription, type, value) {
  subscription._state = "running";
  const observer = subscription._observer;
  try {
    const m = observer ? getMethod(observer, type) : void 0;
    switch (type) {
      case "next":
        if (m)
          m.call(observer, value);
        break;
      case "error":
        closeSubscription(subscription);
        if (m)
          m.call(observer, value);
        else
          throw value;
        break;
      case "complete":
        closeSubscription(subscription);
        if (m)
          m.call(observer);
        break;
    }
  } catch (e) {
    hostReportError(e);
  }
  if (subscription._state === "closed") {
    cleanupSubscription(subscription);
  } else if (subscription._state === "running") {
    subscription._state = "ready";
  }
}
function onNotify(subscription, type, value) {
  if (subscription._state === "closed") {
    return;
  }
  if (subscription._state === "buffering") {
    subscription._queue = subscription._queue || [];
    subscription._queue.push({ type, value });
    return;
  }
  if (subscription._state !== "ready") {
    subscription._state = "buffering";
    subscription._queue = [{ type, value }];
    enqueue(() => flushSubscription(subscription));
    return;
  }
  notifySubscription(subscription, type, value);
}
var SymbolIterator, SymbolObservable, SymbolSpecies, Subscription, SubscriptionObserver, Observable, observable_default;
var init_observable = __esm({
  "node_modules/observable-fns/dist.esm/observable.js"() {
    init_symbols();
    init_symbols2();
    SymbolIterator = getSymbol("iterator");
    SymbolObservable = getSymbol("observable");
    SymbolSpecies = getSymbol("species");
    Subscription = class {
      constructor(observer, subscriber) {
        this._cleanup = void 0;
        this._observer = observer;
        this._queue = void 0;
        this._state = "initializing";
        const subscriptionObserver = new SubscriptionObserver(this);
        try {
          this._cleanup = subscriber.call(void 0, subscriptionObserver);
        } catch (e) {
          subscriptionObserver.error(e);
        }
        if (this._state === "initializing") {
          this._state = "ready";
        }
      }
      get closed() {
        return this._state === "closed";
      }
      unsubscribe() {
        if (this._state !== "closed") {
          closeSubscription(this);
          cleanupSubscription(this);
        }
      }
    };
    SubscriptionObserver = class {
      constructor(subscription) {
        this._subscription = subscription;
      }
      get closed() {
        return this._subscription._state === "closed";
      }
      next(value) {
        onNotify(this._subscription, "next", value);
      }
      error(value) {
        onNotify(this._subscription, "error", value);
      }
      complete() {
        onNotify(this._subscription, "complete");
      }
    };
    Observable = class _Observable {
      constructor(subscriber) {
        if (!(this instanceof _Observable)) {
          throw new TypeError("Observable cannot be called as a function");
        }
        if (typeof subscriber !== "function") {
          throw new TypeError("Observable initializer must be a function");
        }
        this._subscriber = subscriber;
      }
      subscribe(nextOrObserver, onError, onComplete) {
        if (typeof nextOrObserver !== "object" || nextOrObserver === null) {
          nextOrObserver = {
            next: nextOrObserver,
            error: onError,
            complete: onComplete
          };
        }
        return new Subscription(nextOrObserver, this._subscriber);
      }
      pipe(first, ...mappers) {
        let intermediate = this;
        for (const mapper of [first, ...mappers]) {
          intermediate = mapper(intermediate);
        }
        return intermediate;
      }
      tap(nextOrObserver, onError, onComplete) {
        const tapObserver = typeof nextOrObserver !== "object" || nextOrObserver === null ? {
          next: nextOrObserver,
          error: onError,
          complete: onComplete
        } : nextOrObserver;
        return new _Observable((observer) => {
          return this.subscribe({
            next(value) {
              tapObserver.next && tapObserver.next(value);
              observer.next(value);
            },
            error(error) {
              tapObserver.error && tapObserver.error(error);
              observer.error(error);
            },
            complete() {
              tapObserver.complete && tapObserver.complete();
              observer.complete();
            },
            start(subscription) {
              tapObserver.start && tapObserver.start(subscription);
            }
          });
        });
      }
      forEach(fn) {
        return new Promise((resolve, reject) => {
          if (typeof fn !== "function") {
            reject(new TypeError(fn + " is not a function"));
            return;
          }
          function done() {
            subscription.unsubscribe();
            resolve(void 0);
          }
          const subscription = this.subscribe({
            next(value) {
              try {
                fn(value, done);
              } catch (e) {
                reject(e);
                subscription.unsubscribe();
              }
            },
            error(error) {
              reject(error);
            },
            complete() {
              resolve(void 0);
            }
          });
        });
      }
      map(fn) {
        if (typeof fn !== "function") {
          throw new TypeError(fn + " is not a function");
        }
        const C = getSpecies(this);
        return new C((observer) => this.subscribe({
          next(value) {
            let propagatedValue = value;
            try {
              propagatedValue = fn(value);
            } catch (e) {
              return observer.error(e);
            }
            observer.next(propagatedValue);
          },
          error(e) {
            observer.error(e);
          },
          complete() {
            observer.complete();
          }
        }));
      }
      filter(fn) {
        if (typeof fn !== "function") {
          throw new TypeError(fn + " is not a function");
        }
        const C = getSpecies(this);
        return new C((observer) => this.subscribe({
          next(value) {
            try {
              if (!fn(value))
                return;
            } catch (e) {
              return observer.error(e);
            }
            observer.next(value);
          },
          error(e) {
            observer.error(e);
          },
          complete() {
            observer.complete();
          }
        }));
      }
      reduce(fn, seed) {
        if (typeof fn !== "function") {
          throw new TypeError(fn + " is not a function");
        }
        const C = getSpecies(this);
        const hasSeed = arguments.length > 1;
        let hasValue = false;
        let acc = seed;
        return new C((observer) => this.subscribe({
          next(value) {
            const first = !hasValue;
            hasValue = true;
            if (!first || hasSeed) {
              try {
                acc = fn(acc, value);
              } catch (e) {
                return observer.error(e);
              }
            } else {
              acc = value;
            }
          },
          error(e) {
            observer.error(e);
          },
          complete() {
            if (!hasValue && !hasSeed) {
              return observer.error(new TypeError("Cannot reduce an empty sequence"));
            }
            observer.next(acc);
            observer.complete();
          }
        }));
      }
      concat(...sources) {
        const C = getSpecies(this);
        return new C((observer) => {
          let subscription;
          let index = 0;
          function startNext(next) {
            subscription = next.subscribe({
              next(v) {
                observer.next(v);
              },
              error(e) {
                observer.error(e);
              },
              complete() {
                if (index === sources.length) {
                  subscription = void 0;
                  observer.complete();
                } else {
                  startNext(C.from(sources[index++]));
                }
              }
            });
          }
          startNext(this);
          return () => {
            if (subscription) {
              subscription.unsubscribe();
              subscription = void 0;
            }
          };
        });
      }
      flatMap(fn) {
        if (typeof fn !== "function") {
          throw new TypeError(fn + " is not a function");
        }
        const C = getSpecies(this);
        return new C((observer) => {
          const subscriptions = [];
          const outer = this.subscribe({
            next(value) {
              let normalizedValue;
              if (fn) {
                try {
                  normalizedValue = fn(value);
                } catch (e) {
                  return observer.error(e);
                }
              } else {
                normalizedValue = value;
              }
              const inner = C.from(normalizedValue).subscribe({
                next(innerValue) {
                  observer.next(innerValue);
                },
                error(e) {
                  observer.error(e);
                },
                complete() {
                  const i = subscriptions.indexOf(inner);
                  if (i >= 0)
                    subscriptions.splice(i, 1);
                  completeIfDone();
                }
              });
              subscriptions.push(inner);
            },
            error(e) {
              observer.error(e);
            },
            complete() {
              completeIfDone();
            }
          });
          function completeIfDone() {
            if (outer.closed && subscriptions.length === 0) {
              observer.complete();
            }
          }
          return () => {
            subscriptions.forEach((s) => s.unsubscribe());
            outer.unsubscribe();
          };
        });
      }
      [(Symbol.observable, SymbolObservable)]() {
        return this;
      }
      static from(x) {
        const C = typeof this === "function" ? this : _Observable;
        if (x == null) {
          throw new TypeError(x + " is not an object");
        }
        const observableMethod = getMethod(x, SymbolObservable);
        if (observableMethod) {
          const observable = observableMethod.call(x);
          if (Object(observable) !== observable) {
            throw new TypeError(observable + " is not an object");
          }
          if (isObservable(observable) && observable.constructor === C) {
            return observable;
          }
          return new C((observer) => observable.subscribe(observer));
        }
        if (hasSymbol("iterator")) {
          const iteratorMethod = getMethod(x, SymbolIterator);
          if (iteratorMethod) {
            return new C((observer) => {
              enqueue(() => {
                if (observer.closed)
                  return;
                for (const item of iteratorMethod.call(x)) {
                  observer.next(item);
                  if (observer.closed)
                    return;
                }
                observer.complete();
              });
            });
          }
        }
        if (Array.isArray(x)) {
          return new C((observer) => {
            enqueue(() => {
              if (observer.closed)
                return;
              for (const item of x) {
                observer.next(item);
                if (observer.closed)
                  return;
              }
              observer.complete();
            });
          });
        }
        throw new TypeError(x + " is not observable");
      }
      static of(...items) {
        const C = typeof this === "function" ? this : _Observable;
        return new C((observer) => {
          enqueue(() => {
            if (observer.closed)
              return;
            for (const item of items) {
              observer.next(item);
              if (observer.closed)
                return;
            }
            observer.complete();
          });
        });
      }
      static get [SymbolSpecies]() {
        return this;
      }
    };
    if (hasSymbols()) {
      Object.defineProperty(Observable, Symbol("extensions"), {
        value: {
          symbol: SymbolObservable,
          hostReportError
        },
        configurable: true
      });
    }
    observable_default = Observable;
  }
});

// node_modules/observable-fns/dist.esm/unsubscribe.js
function unsubscribe(subscription) {
  if (typeof subscription === "function") {
    subscription();
  } else if (subscription && typeof subscription.unsubscribe === "function") {
    subscription.unsubscribe();
  }
}
var unsubscribe_default;
var init_unsubscribe = __esm({
  "node_modules/observable-fns/dist.esm/unsubscribe.js"() {
    unsubscribe_default = unsubscribe;
  }
});

// node_modules/observable-fns/dist.esm/filter.js
function filter(test) {
  return (observable) => {
    return new observable_default((observer) => {
      const scheduler = new AsyncSerialScheduler(observer);
      const subscription = observable.subscribe({
        complete() {
          scheduler.complete();
        },
        error(error) {
          scheduler.error(error);
        },
        next(input) {
          scheduler.schedule((next) => __awaiter2(this, void 0, void 0, function* () {
            if (yield test(input)) {
              next(input);
            }
          }));
        }
      });
      return () => unsubscribe_default(subscription);
    });
  };
}
var __awaiter2, filter_default;
var init_filter = __esm({
  "node_modules/observable-fns/dist.esm/filter.js"() {
    init_scheduler();
    init_observable();
    init_unsubscribe();
    __awaiter2 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    filter_default = filter;
  }
});

// node_modules/observable-fns/dist.esm/_util.js
function isAsyncIterator(thing) {
  return thing && hasSymbol("asyncIterator") && thing[Symbol.asyncIterator];
}
function isIterator(thing) {
  return thing && hasSymbol("iterator") && thing[Symbol.iterator];
}
var init_util = __esm({
  "node_modules/observable-fns/dist.esm/_util.js"() {
    init_symbols2();
  }
});

// node_modules/observable-fns/dist.esm/flatMap.js
function flatMap(mapper) {
  return (observable) => {
    return new observable_default((observer) => {
      const scheduler = new AsyncSerialScheduler(observer);
      const subscription = observable.subscribe({
        complete() {
          scheduler.complete();
        },
        error(error) {
          scheduler.error(error);
        },
        next(input) {
          scheduler.schedule((next) => __awaiter3(this, void 0, void 0, function* () {
            var e_1, _a;
            const mapped = yield mapper(input);
            if (isIterator(mapped) || isAsyncIterator(mapped)) {
              try {
                for (var mapped_1 = __asyncValues(mapped), mapped_1_1; mapped_1_1 = yield mapped_1.next(), !mapped_1_1.done; ) {
                  const element = mapped_1_1.value;
                  next(element);
                }
              } catch (e_1_1) {
                e_1 = { error: e_1_1 };
              } finally {
                try {
                  if (mapped_1_1 && !mapped_1_1.done && (_a = mapped_1.return)) yield _a.call(mapped_1);
                } finally {
                  if (e_1) throw e_1.error;
                }
              }
            } else {
              mapped.map((output) => next(output));
            }
          }));
        }
      });
      return () => unsubscribe_default(subscription);
    });
  };
}
var __awaiter3, __asyncValues, flatMap_default;
var init_flatMap = __esm({
  "node_modules/observable-fns/dist.esm/flatMap.js"() {
    init_scheduler();
    init_util();
    init_observable();
    init_unsubscribe();
    __awaiter3 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    __asyncValues = function(o) {
      if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i);
      function verb(n) {
        i[n] = o[n] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve({ value: v2, done: d });
        }, reject);
      }
    };
    flatMap_default = flatMap;
  }
});

// node_modules/observable-fns/dist.esm/interval.js
function interval(period) {
  return new Observable((observer) => {
    let counter = 0;
    const handle = setInterval(() => {
      observer.next(counter++);
    }, period);
    return () => clearInterval(handle);
  });
}
var init_interval = __esm({
  "node_modules/observable-fns/dist.esm/interval.js"() {
    init_observable();
  }
});

// node_modules/observable-fns/dist.esm/map.js
function map(mapper) {
  return (observable) => {
    return new observable_default((observer) => {
      const scheduler = new AsyncSerialScheduler(observer);
      const subscription = observable.subscribe({
        complete() {
          scheduler.complete();
        },
        error(error) {
          scheduler.error(error);
        },
        next(input) {
          scheduler.schedule((next) => __awaiter4(this, void 0, void 0, function* () {
            const mapped = yield mapper(input);
            next(mapped);
          }));
        }
      });
      return () => unsubscribe_default(subscription);
    });
  };
}
var __awaiter4, map_default;
var init_map = __esm({
  "node_modules/observable-fns/dist.esm/map.js"() {
    init_scheduler();
    init_observable();
    init_unsubscribe();
    __awaiter4 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    map_default = map;
  }
});

// node_modules/observable-fns/dist.esm/merge.js
function merge(...observables) {
  if (observables.length === 0) {
    return Observable.from([]);
  }
  return new Observable((observer) => {
    let completed = 0;
    const subscriptions = observables.map((input) => {
      return input.subscribe({
        error(error) {
          observer.error(error);
          unsubscribeAll();
        },
        next(value) {
          observer.next(value);
        },
        complete() {
          if (++completed === observables.length) {
            observer.complete();
            unsubscribeAll();
          }
        }
      });
    });
    const unsubscribeAll = () => {
      subscriptions.forEach((subscription) => unsubscribe_default(subscription));
    };
    return unsubscribeAll;
  });
}
var merge_default;
var init_merge = __esm({
  "node_modules/observable-fns/dist.esm/merge.js"() {
    init_observable();
    init_unsubscribe();
    merge_default = merge;
  }
});

// node_modules/observable-fns/dist.esm/subject.js
var MulticastSubject, subject_default;
var init_subject = __esm({
  "node_modules/observable-fns/dist.esm/subject.js"() {
    init_observable();
    MulticastSubject = class extends observable_default {
      constructor() {
        super((observer) => {
          this._observers.add(observer);
          return () => this._observers.delete(observer);
        });
        this._observers = /* @__PURE__ */ new Set();
      }
      next(value) {
        for (const observer of this._observers) {
          observer.next(value);
        }
      }
      error(error) {
        for (const observer of this._observers) {
          observer.error(error);
        }
      }
      complete() {
        for (const observer of this._observers) {
          observer.complete();
        }
      }
    };
    subject_default = MulticastSubject;
  }
});

// node_modules/observable-fns/dist.esm/multicast.js
function multicast(coldObservable) {
  const subject = new subject_default();
  let sourceSubscription;
  let subscriberCount = 0;
  return new observable_default((observer) => {
    if (!sourceSubscription) {
      sourceSubscription = coldObservable.subscribe(subject);
    }
    const subscription = subject.subscribe(observer);
    subscriberCount++;
    return () => {
      subscriberCount--;
      subscription.unsubscribe();
      if (subscriberCount === 0) {
        unsubscribe_default(sourceSubscription);
        sourceSubscription = void 0;
      }
    };
  });
}
var multicast_default;
var init_multicast = __esm({
  "node_modules/observable-fns/dist.esm/multicast.js"() {
    init_observable();
    init_subject();
    init_unsubscribe();
    multicast_default = multicast;
  }
});

// node_modules/observable-fns/dist.esm/scan.js
function scan(accumulator, seed) {
  return (observable) => {
    return new observable_default((observer) => {
      let accumulated;
      let index = 0;
      const scheduler = new AsyncSerialScheduler(observer);
      const subscription = observable.subscribe({
        complete() {
          scheduler.complete();
        },
        error(error) {
          scheduler.error(error);
        },
        next(value) {
          scheduler.schedule((next) => __awaiter5(this, void 0, void 0, function* () {
            const prevAcc = index === 0 ? typeof seed === "undefined" ? value : seed : accumulated;
            accumulated = yield accumulator(prevAcc, value, index++);
            next(accumulated);
          }));
        }
      });
      return () => unsubscribe_default(subscription);
    });
  };
}
var __awaiter5, scan_default;
var init_scan = __esm({
  "node_modules/observable-fns/dist.esm/scan.js"() {
    init_scheduler();
    init_observable();
    init_unsubscribe();
    __awaiter5 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    scan_default = scan;
  }
});

// node_modules/observable-fns/dist.esm/index.js
var dist_exports = {};
__export(dist_exports, {
  Observable: () => observable_default,
  Subject: () => subject_default,
  filter: () => filter_default,
  flatMap: () => flatMap_default,
  interval: () => interval,
  map: () => map_default,
  merge: () => merge_default,
  multicast: () => multicast_default,
  scan: () => scan_default,
  unsubscribe: () => unsubscribe_default
});
var init_dist = __esm({
  "node_modules/observable-fns/dist.esm/index.js"() {
    init_filter();
    init_flatMap();
    init_interval();
    init_map();
    init_merge();
    init_multicast();
    init_observable();
    init_scan();
    init_subject();
    init_unsubscribe();
  }
});

// node_modules/threads/dist/ponyfills.js
var require_ponyfills = __commonJS({
  "node_modules/threads/dist/ponyfills.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.allSettled = void 0;
    function allSettled(values) {
      return Promise.all(values.map((item) => {
        const onFulfill = (value) => {
          return { status: "fulfilled", value };
        };
        const onReject = (reason) => {
          return { status: "rejected", reason };
        };
        const itemPromise = Promise.resolve(item);
        try {
          return itemPromise.then(onFulfill, onReject);
        } catch (error) {
          return Promise.reject(error);
        }
      }));
    }
    exports.allSettled = allSettled;
  }
});

// node_modules/threads/dist/master/pool-types.js
var require_pool_types = __commonJS({
  "node_modules/threads/dist/master/pool-types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PoolEventType = void 0;
    var PoolEventType;
    (function(PoolEventType2) {
      PoolEventType2["initialized"] = "initialized";
      PoolEventType2["taskCanceled"] = "taskCanceled";
      PoolEventType2["taskCompleted"] = "taskCompleted";
      PoolEventType2["taskFailed"] = "taskFailed";
      PoolEventType2["taskQueued"] = "taskQueued";
      PoolEventType2["taskQueueDrained"] = "taskQueueDrained";
      PoolEventType2["taskStart"] = "taskStart";
      PoolEventType2["terminated"] = "terminated";
    })(PoolEventType = exports.PoolEventType || (exports.PoolEventType = {}));
  }
});

// node_modules/threads/dist/symbols.js
var require_symbols = __commonJS({
  "node_modules/threads/dist/symbols.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$worker = exports.$transferable = exports.$terminate = exports.$events = exports.$errors = void 0;
    exports.$errors = Symbol("thread.errors");
    exports.$events = Symbol("thread.events");
    exports.$terminate = Symbol("thread.terminate");
    exports.$transferable = Symbol("thread.transferable");
    exports.$worker = Symbol("thread.worker");
  }
});

// node_modules/threads/dist/master/thread.js
var require_thread = __commonJS({
  "node_modules/threads/dist/master/thread.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Thread = void 0;
    var symbols_1 = require_symbols();
    function fail(message) {
      throw Error(message);
    }
    exports.Thread = {
      /** Return an observable that can be used to subscribe to all errors happening in the thread. */
      errors(thread) {
        return thread[symbols_1.$errors] || fail("Error observable not found. Make sure to pass a thread instance as returned by the spawn() promise.");
      },
      /** Return an observable that can be used to subscribe to internal events happening in the thread. Useful for debugging. */
      events(thread) {
        return thread[symbols_1.$events] || fail("Events observable not found. Make sure to pass a thread instance as returned by the spawn() promise.");
      },
      /** Terminate a thread. Remember to terminate every thread when you are done using it. */
      terminate(thread) {
        return thread[symbols_1.$terminate]();
      }
    };
  }
});

// node_modules/threads/dist/master/pool.js
var require_pool = __commonJS({
  "node_modules/threads/dist/master/pool.js"(exports) {
    "use strict";
    var __awaiter6 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Pool = exports.Thread = exports.PoolEventType = void 0;
    var debug_1 = __importDefault(require_browser());
    var observable_fns_1 = (init_dist(), __toCommonJS(dist_exports));
    var ponyfills_1 = require_ponyfills();
    var implementation_1 = require_implementation_browser();
    var pool_types_1 = require_pool_types();
    Object.defineProperty(exports, "PoolEventType", { enumerable: true, get: function() {
      return pool_types_1.PoolEventType;
    } });
    var thread_1 = require_thread();
    Object.defineProperty(exports, "Thread", { enumerable: true, get: function() {
      return thread_1.Thread;
    } });
    var nextPoolID = 1;
    function createArray(size) {
      const array = [];
      for (let index = 0; index < size; index++) {
        array.push(index);
      }
      return array;
    }
    function delay(ms) {
      return new Promise((resolve) => setTimeout(resolve, ms));
    }
    function flatMap2(array, mapper) {
      return array.reduce((flattened, element) => [...flattened, ...mapper(element)], []);
    }
    function slugify(text) {
      return text.replace(/\W/g, " ").trim().replace(/\s+/g, "-");
    }
    function spawnWorkers(spawnWorker, count) {
      return createArray(count).map(() => ({
        init: spawnWorker(),
        runningTasks: []
      }));
    }
    var WorkerPool = class {
      constructor(spawnWorker, optionsOrSize) {
        this.eventSubject = new observable_fns_1.Subject();
        this.initErrors = [];
        this.isClosing = false;
        this.nextTaskID = 1;
        this.taskQueue = [];
        const options = typeof optionsOrSize === "number" ? { size: optionsOrSize } : optionsOrSize || {};
        const { size = implementation_1.defaultPoolSize } = options;
        this.debug = debug_1.default(`threads:pool:${slugify(options.name || String(nextPoolID++))}`);
        this.options = options;
        this.workers = spawnWorkers(spawnWorker, size);
        this.eventObservable = observable_fns_1.multicast(observable_fns_1.Observable.from(this.eventSubject));
        Promise.all(this.workers.map((worker) => worker.init)).then(() => this.eventSubject.next({
          type: pool_types_1.PoolEventType.initialized,
          size: this.workers.length
        }), (error) => {
          this.debug("Error while initializing pool worker:", error);
          this.eventSubject.error(error);
          this.initErrors.push(error);
        });
      }
      findIdlingWorker() {
        const { concurrency = 1 } = this.options;
        return this.workers.find((worker) => worker.runningTasks.length < concurrency);
      }
      runPoolTask(worker, task) {
        return __awaiter6(this, void 0, void 0, function* () {
          const workerID = this.workers.indexOf(worker) + 1;
          this.debug(`Running task #${task.id} on worker #${workerID}...`);
          this.eventSubject.next({
            type: pool_types_1.PoolEventType.taskStart,
            taskID: task.id,
            workerID
          });
          try {
            const returnValue = yield task.run(yield worker.init);
            this.debug(`Task #${task.id} completed successfully`);
            this.eventSubject.next({
              type: pool_types_1.PoolEventType.taskCompleted,
              returnValue,
              taskID: task.id,
              workerID
            });
          } catch (error) {
            this.debug(`Task #${task.id} failed`);
            this.eventSubject.next({
              type: pool_types_1.PoolEventType.taskFailed,
              taskID: task.id,
              error,
              workerID
            });
          }
        });
      }
      run(worker, task) {
        return __awaiter6(this, void 0, void 0, function* () {
          const runPromise = (() => __awaiter6(this, void 0, void 0, function* () {
            const removeTaskFromWorkersRunningTasks = () => {
              worker.runningTasks = worker.runningTasks.filter((someRunPromise) => someRunPromise !== runPromise);
            };
            yield delay(0);
            try {
              yield this.runPoolTask(worker, task);
            } finally {
              removeTaskFromWorkersRunningTasks();
              if (!this.isClosing) {
                this.scheduleWork();
              }
            }
          }))();
          worker.runningTasks.push(runPromise);
        });
      }
      scheduleWork() {
        this.debug(`Attempt de-queueing a task in order to run it...`);
        const availableWorker = this.findIdlingWorker();
        if (!availableWorker)
          return;
        const nextTask = this.taskQueue.shift();
        if (!nextTask) {
          this.debug(`Task queue is empty`);
          this.eventSubject.next({ type: pool_types_1.PoolEventType.taskQueueDrained });
          return;
        }
        this.run(availableWorker, nextTask);
      }
      taskCompletion(taskID) {
        return new Promise((resolve, reject) => {
          const eventSubscription = this.events().subscribe((event) => {
            if (event.type === pool_types_1.PoolEventType.taskCompleted && event.taskID === taskID) {
              eventSubscription.unsubscribe();
              resolve(event.returnValue);
            } else if (event.type === pool_types_1.PoolEventType.taskFailed && event.taskID === taskID) {
              eventSubscription.unsubscribe();
              reject(event.error);
            } else if (event.type === pool_types_1.PoolEventType.terminated) {
              eventSubscription.unsubscribe();
              reject(Error("Pool has been terminated before task was run."));
            }
          });
        });
      }
      settled(allowResolvingImmediately = false) {
        return __awaiter6(this, void 0, void 0, function* () {
          const getCurrentlyRunningTasks = () => flatMap2(this.workers, (worker) => worker.runningTasks);
          const taskFailures = [];
          const failureSubscription = this.eventObservable.subscribe((event) => {
            if (event.type === pool_types_1.PoolEventType.taskFailed) {
              taskFailures.push(event.error);
            }
          });
          if (this.initErrors.length > 0) {
            return Promise.reject(this.initErrors[0]);
          }
          if (allowResolvingImmediately && this.taskQueue.length === 0) {
            yield ponyfills_1.allSettled(getCurrentlyRunningTasks());
            return taskFailures;
          }
          yield new Promise((resolve, reject) => {
            const subscription = this.eventObservable.subscribe({
              next(event) {
                if (event.type === pool_types_1.PoolEventType.taskQueueDrained) {
                  subscription.unsubscribe();
                  resolve(void 0);
                }
              },
              error: reject
              // make a pool-wide error reject the completed() result promise
            });
          });
          yield ponyfills_1.allSettled(getCurrentlyRunningTasks());
          failureSubscription.unsubscribe();
          return taskFailures;
        });
      }
      completed(allowResolvingImmediately = false) {
        return __awaiter6(this, void 0, void 0, function* () {
          const settlementPromise = this.settled(allowResolvingImmediately);
          const earlyExitPromise = new Promise((resolve, reject) => {
            const subscription = this.eventObservable.subscribe({
              next(event) {
                if (event.type === pool_types_1.PoolEventType.taskQueueDrained) {
                  subscription.unsubscribe();
                  resolve(settlementPromise);
                } else if (event.type === pool_types_1.PoolEventType.taskFailed) {
                  subscription.unsubscribe();
                  reject(event.error);
                }
              },
              error: reject
              // make a pool-wide error reject the completed() result promise
            });
          });
          const errors = yield Promise.race([
            settlementPromise,
            earlyExitPromise
          ]);
          if (errors.length > 0) {
            throw errors[0];
          }
        });
      }
      events() {
        return this.eventObservable;
      }
      queue(taskFunction) {
        const { maxQueuedJobs = Infinity } = this.options;
        if (this.isClosing) {
          throw Error(`Cannot schedule pool tasks after terminate() has been called.`);
        }
        if (this.initErrors.length > 0) {
          throw this.initErrors[0];
        }
        const taskID = this.nextTaskID++;
        const taskCompletion = this.taskCompletion(taskID);
        taskCompletion.catch((error) => {
          this.debug(`Task #${taskID} errored:`, error);
        });
        const task = {
          id: taskID,
          run: taskFunction,
          cancel: () => {
            if (this.taskQueue.indexOf(task) === -1)
              return;
            this.taskQueue = this.taskQueue.filter((someTask) => someTask !== task);
            this.eventSubject.next({
              type: pool_types_1.PoolEventType.taskCanceled,
              taskID: task.id
            });
          },
          then: taskCompletion.then.bind(taskCompletion)
        };
        if (this.taskQueue.length >= maxQueuedJobs) {
          throw Error("Maximum number of pool tasks queued. Refusing to queue another one.\nThis usually happens for one of two reasons: We are either at peak workload right now or some tasks just won't finish, thus blocking the pool.");
        }
        this.debug(`Queueing task #${task.id}...`);
        this.taskQueue.push(task);
        this.eventSubject.next({
          type: pool_types_1.PoolEventType.taskQueued,
          taskID: task.id
        });
        this.scheduleWork();
        return task;
      }
      terminate(force) {
        return __awaiter6(this, void 0, void 0, function* () {
          this.isClosing = true;
          if (!force) {
            yield this.completed(true);
          }
          this.eventSubject.next({
            type: pool_types_1.PoolEventType.terminated,
            remainingQueue: [...this.taskQueue]
          });
          this.eventSubject.complete();
          yield Promise.all(this.workers.map((worker) => __awaiter6(this, void 0, void 0, function* () {
            return thread_1.Thread.terminate(yield worker.init);
          })));
        });
      }
    };
    WorkerPool.EventType = pool_types_1.PoolEventType;
    function PoolConstructor(spawnWorker, optionsOrSize) {
      return new WorkerPool(spawnWorker, optionsOrSize);
    }
    PoolConstructor.EventType = pool_types_1.PoolEventType;
    exports.Pool = PoolConstructor;
  }
});

// node_modules/threads/dist/promise.js
var require_promise = __commonJS({
  "node_modules/threads/dist/promise.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createPromiseWithResolver = void 0;
    var doNothing = () => void 0;
    function createPromiseWithResolver() {
      let alreadyResolved = false;
      let resolvedTo;
      let resolver = doNothing;
      const promise = new Promise((resolve) => {
        if (alreadyResolved) {
          resolve(resolvedTo);
        } else {
          resolver = resolve;
        }
      });
      const exposedResolver = (value) => {
        alreadyResolved = true;
        resolvedTo = value;
        resolver(resolvedTo);
      };
      return [promise, exposedResolver];
    }
    exports.createPromiseWithResolver = createPromiseWithResolver;
  }
});

// node_modules/threads/dist/types/master.js
var require_master = __commonJS({
  "node_modules/threads/dist/types/master.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WorkerEventType = void 0;
    var symbols_1 = require_symbols();
    var WorkerEventType;
    (function(WorkerEventType2) {
      WorkerEventType2["internalError"] = "internalError";
      WorkerEventType2["message"] = "message";
      WorkerEventType2["termination"] = "termination";
    })(WorkerEventType = exports.WorkerEventType || (exports.WorkerEventType = {}));
  }
});

// node_modules/threads/dist/observable-promise.js
var require_observable_promise = __commonJS({
  "node_modules/threads/dist/observable-promise.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ObservablePromise = void 0;
    var observable_fns_1 = (init_dist(), __toCommonJS(dist_exports));
    var doNothing = () => void 0;
    var returnInput = (input) => input;
    var runDeferred = (fn) => Promise.resolve().then(fn);
    function fail(error) {
      throw error;
    }
    function isThenable(thing) {
      return thing && typeof thing.then === "function";
    }
    var ObservablePromise = class _ObservablePromise extends observable_fns_1.Observable {
      constructor(init) {
        super((originalObserver) => {
          const self2 = this;
          const observer = Object.assign(Object.assign({}, originalObserver), {
            complete() {
              originalObserver.complete();
              self2.onCompletion();
            },
            error(error) {
              originalObserver.error(error);
              self2.onError(error);
            },
            next(value) {
              originalObserver.next(value);
              self2.onNext(value);
            }
          });
          try {
            this.initHasRun = true;
            return init(observer);
          } catch (error) {
            observer.error(error);
          }
        });
        this.initHasRun = false;
        this.fulfillmentCallbacks = [];
        this.rejectionCallbacks = [];
        this.firstValueSet = false;
        this.state = "pending";
      }
      onNext(value) {
        if (!this.firstValueSet) {
          this.firstValue = value;
          this.firstValueSet = true;
        }
      }
      onError(error) {
        this.state = "rejected";
        this.rejection = error;
        for (const onRejected of this.rejectionCallbacks) {
          runDeferred(() => onRejected(error));
        }
      }
      onCompletion() {
        this.state = "fulfilled";
        for (const onFulfilled of this.fulfillmentCallbacks) {
          runDeferred(() => onFulfilled(this.firstValue));
        }
      }
      then(onFulfilledRaw, onRejectedRaw) {
        const onFulfilled = onFulfilledRaw || returnInput;
        const onRejected = onRejectedRaw || fail;
        let onRejectedCalled = false;
        return new Promise((resolve, reject) => {
          const rejectionCallback = (error) => {
            if (onRejectedCalled)
              return;
            onRejectedCalled = true;
            try {
              resolve(onRejected(error));
            } catch (anotherError) {
              reject(anotherError);
            }
          };
          const fulfillmentCallback = (value) => {
            try {
              resolve(onFulfilled(value));
            } catch (error) {
              rejectionCallback(error);
            }
          };
          if (!this.initHasRun) {
            this.subscribe({ error: rejectionCallback });
          }
          if (this.state === "fulfilled") {
            return resolve(onFulfilled(this.firstValue));
          }
          if (this.state === "rejected") {
            onRejectedCalled = true;
            return resolve(onRejected(this.rejection));
          }
          this.fulfillmentCallbacks.push(fulfillmentCallback);
          this.rejectionCallbacks.push(rejectionCallback);
        });
      }
      catch(onRejected) {
        return this.then(void 0, onRejected);
      }
      finally(onCompleted) {
        const handler = onCompleted || doNothing;
        return this.then((value) => {
          handler();
          return value;
        }, () => handler());
      }
      static from(thing) {
        if (isThenable(thing)) {
          return new _ObservablePromise((observer) => {
            const onFulfilled = (value) => {
              observer.next(value);
              observer.complete();
            };
            const onRejected = (error) => {
              observer.error(error);
            };
            thing.then(onFulfilled, onRejected);
          });
        } else {
          return super.from(thing);
        }
      }
    };
    exports.ObservablePromise = ObservablePromise;
  }
});

// node_modules/threads/dist/transferable.js
var require_transferable = __commonJS({
  "node_modules/threads/dist/transferable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Transfer = exports.isTransferDescriptor = void 0;
    var symbols_1 = require_symbols();
    function isTransferable(thing) {
      if (!thing || typeof thing !== "object")
        return false;
      return true;
    }
    function isTransferDescriptor(thing) {
      return thing && typeof thing === "object" && thing[symbols_1.$transferable];
    }
    exports.isTransferDescriptor = isTransferDescriptor;
    function Transfer3(payload, transferables) {
      if (!transferables) {
        if (!isTransferable(payload))
          throw Error();
        transferables = [payload];
      }
      return {
        [symbols_1.$transferable]: true,
        send: payload,
        transferables
      };
    }
    exports.Transfer = Transfer3;
  }
});

// node_modules/threads/dist/types/messages.js
var require_messages = __commonJS({
  "node_modules/threads/dist/types/messages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WorkerMessageType = exports.MasterMessageType = void 0;
    var MasterMessageType;
    (function(MasterMessageType2) {
      MasterMessageType2["cancel"] = "cancel";
      MasterMessageType2["run"] = "run";
    })(MasterMessageType = exports.MasterMessageType || (exports.MasterMessageType = {}));
    var WorkerMessageType;
    (function(WorkerMessageType2) {
      WorkerMessageType2["error"] = "error";
      WorkerMessageType2["init"] = "init";
      WorkerMessageType2["result"] = "result";
      WorkerMessageType2["running"] = "running";
      WorkerMessageType2["uncaughtError"] = "uncaughtError";
    })(WorkerMessageType = exports.WorkerMessageType || (exports.WorkerMessageType = {}));
  }
});

// node_modules/threads/dist/master/invocation-proxy.js
var require_invocation_proxy = __commonJS({
  "node_modules/threads/dist/master/invocation-proxy.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createProxyModule = exports.createProxyFunction = void 0;
    var debug_1 = __importDefault(require_browser());
    var observable_fns_1 = (init_dist(), __toCommonJS(dist_exports));
    var common_1 = require_common();
    var observable_promise_1 = require_observable_promise();
    var transferable_1 = require_transferable();
    var messages_1 = require_messages();
    var debugMessages = debug_1.default("threads:master:messages");
    var nextJobUID = 1;
    var dedupe = (array) => Array.from(new Set(array));
    var isJobErrorMessage = (data) => data && data.type === messages_1.WorkerMessageType.error;
    var isJobResultMessage = (data) => data && data.type === messages_1.WorkerMessageType.result;
    var isJobStartMessage = (data) => data && data.type === messages_1.WorkerMessageType.running;
    function createObservableForJob(worker, jobUID) {
      return new observable_fns_1.Observable((observer) => {
        let asyncType;
        const messageHandler = (event) => {
          debugMessages("Message from worker:", event.data);
          if (!event.data || event.data.uid !== jobUID)
            return;
          if (isJobStartMessage(event.data)) {
            asyncType = event.data.resultType;
          } else if (isJobResultMessage(event.data)) {
            if (asyncType === "promise") {
              if (typeof event.data.payload !== "undefined") {
                observer.next(common_1.deserialize(event.data.payload));
              }
              observer.complete();
              worker.removeEventListener("message", messageHandler);
            } else {
              if (event.data.payload) {
                observer.next(common_1.deserialize(event.data.payload));
              }
              if (event.data.complete) {
                observer.complete();
                worker.removeEventListener("message", messageHandler);
              }
            }
          } else if (isJobErrorMessage(event.data)) {
            const error = common_1.deserialize(event.data.error);
            if (asyncType === "promise" || !asyncType) {
              observer.error(error);
            } else {
              observer.error(error);
            }
            worker.removeEventListener("message", messageHandler);
          }
        };
        worker.addEventListener("message", messageHandler);
        return () => {
          if (asyncType === "observable" || !asyncType) {
            const cancelMessage = {
              type: messages_1.MasterMessageType.cancel,
              uid: jobUID
            };
            worker.postMessage(cancelMessage);
          }
          worker.removeEventListener("message", messageHandler);
        };
      });
    }
    function prepareArguments(rawArgs) {
      if (rawArgs.length === 0) {
        return {
          args: [],
          transferables: []
        };
      }
      const args = [];
      const transferables = [];
      for (const arg of rawArgs) {
        if (transferable_1.isTransferDescriptor(arg)) {
          args.push(common_1.serialize(arg.send));
          transferables.push(...arg.transferables);
        } else {
          args.push(common_1.serialize(arg));
        }
      }
      return {
        args,
        transferables: transferables.length === 0 ? transferables : dedupe(transferables)
      };
    }
    function createProxyFunction(worker, method) {
      return (...rawArgs) => {
        const uid = nextJobUID++;
        const { args, transferables } = prepareArguments(rawArgs);
        const runMessage = {
          type: messages_1.MasterMessageType.run,
          uid,
          method,
          args
        };
        debugMessages("Sending command to run function to worker:", runMessage);
        try {
          worker.postMessage(runMessage, transferables);
        } catch (error) {
          return observable_promise_1.ObservablePromise.from(Promise.reject(error));
        }
        return observable_promise_1.ObservablePromise.from(observable_fns_1.multicast(createObservableForJob(worker, uid)));
      };
    }
    exports.createProxyFunction = createProxyFunction;
    function createProxyModule(worker, methodNames) {
      const proxy = {};
      for (const methodName of methodNames) {
        proxy[methodName] = createProxyFunction(worker, methodName);
      }
      return proxy;
    }
    exports.createProxyModule = createProxyModule;
  }
});

// node_modules/threads/dist/master/spawn.js
var require_spawn = __commonJS({
  "node_modules/threads/dist/master/spawn.js"(exports) {
    "use strict";
    var __awaiter6 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.spawn = void 0;
    var debug_1 = __importDefault(require_browser());
    var observable_fns_1 = (init_dist(), __toCommonJS(dist_exports));
    var common_1 = require_common();
    var promise_1 = require_promise();
    var symbols_1 = require_symbols();
    var master_1 = require_master();
    var invocation_proxy_1 = require_invocation_proxy();
    var debugMessages = debug_1.default("threads:master:messages");
    var debugSpawn = debug_1.default("threads:master:spawn");
    var debugThreadUtils = debug_1.default("threads:master:thread-utils");
    var isInitMessage = (data) => data && data.type === "init";
    var isUncaughtErrorMessage = (data) => data && data.type === "uncaughtError";
    var initMessageTimeout = typeof process !== "undefined" && process.env.THREADS_WORKER_INIT_TIMEOUT ? Number.parseInt(process.env.THREADS_WORKER_INIT_TIMEOUT, 10) : 1e4;
    function withTimeout(promise, timeoutInMs, errorMessage) {
      return __awaiter6(this, void 0, void 0, function* () {
        let timeoutHandle;
        const timeout = new Promise((resolve, reject) => {
          timeoutHandle = setTimeout(() => reject(Error(errorMessage)), timeoutInMs);
        });
        const result = yield Promise.race([
          promise,
          timeout
        ]);
        clearTimeout(timeoutHandle);
        return result;
      });
    }
    function receiveInitMessage(worker) {
      return new Promise((resolve, reject) => {
        const messageHandler = (event) => {
          debugMessages("Message from worker before finishing initialization:", event.data);
          if (isInitMessage(event.data)) {
            worker.removeEventListener("message", messageHandler);
            resolve(event.data);
          } else if (isUncaughtErrorMessage(event.data)) {
            worker.removeEventListener("message", messageHandler);
            reject(common_1.deserialize(event.data.error));
          }
        };
        worker.addEventListener("message", messageHandler);
      });
    }
    function createEventObservable(worker, workerTermination) {
      return new observable_fns_1.Observable((observer) => {
        const messageHandler = (messageEvent) => {
          const workerEvent = {
            type: master_1.WorkerEventType.message,
            data: messageEvent.data
          };
          observer.next(workerEvent);
        };
        const rejectionHandler = (errorEvent) => {
          debugThreadUtils("Unhandled promise rejection event in thread:", errorEvent);
          const workerEvent = {
            type: master_1.WorkerEventType.internalError,
            error: Error(errorEvent.reason)
          };
          observer.next(workerEvent);
        };
        worker.addEventListener("message", messageHandler);
        worker.addEventListener("unhandledrejection", rejectionHandler);
        workerTermination.then(() => {
          const terminationEvent = {
            type: master_1.WorkerEventType.termination
          };
          worker.removeEventListener("message", messageHandler);
          worker.removeEventListener("unhandledrejection", rejectionHandler);
          observer.next(terminationEvent);
          observer.complete();
        });
      });
    }
    function createTerminator(worker) {
      const [termination, resolver] = promise_1.createPromiseWithResolver();
      const terminate = () => __awaiter6(this, void 0, void 0, function* () {
        debugThreadUtils("Terminating worker");
        yield worker.terminate();
        resolver();
      });
      return { terminate, termination };
    }
    function setPrivateThreadProps(raw, worker, workerEvents, terminate) {
      const workerErrors = workerEvents.filter((event) => event.type === master_1.WorkerEventType.internalError).map((errorEvent) => errorEvent.error);
      return Object.assign(raw, {
        [symbols_1.$errors]: workerErrors,
        [symbols_1.$events]: workerEvents,
        [symbols_1.$terminate]: terminate,
        [symbols_1.$worker]: worker
      });
    }
    function spawn2(worker, options) {
      return __awaiter6(this, void 0, void 0, function* () {
        debugSpawn("Initializing new thread");
        const timeout = options && options.timeout ? options.timeout : initMessageTimeout;
        const initMessage = yield withTimeout(receiveInitMessage(worker), timeout, `Timeout: Did not receive an init message from worker after ${timeout}ms. Make sure the worker calls expose().`);
        const exposed = initMessage.exposed;
        const { termination, terminate } = createTerminator(worker);
        const events = createEventObservable(worker, termination);
        if (exposed.type === "function") {
          const proxy = invocation_proxy_1.createProxyFunction(worker);
          return setPrivateThreadProps(proxy, worker, events, terminate);
        } else if (exposed.type === "module") {
          const proxy = invocation_proxy_1.createProxyModule(worker, exposed.methods);
          return setPrivateThreadProps(proxy, worker, events, terminate);
        } else {
          const type = exposed.type;
          throw Error(`Worker init message states unexpected type of expose(): ${type}`);
        }
      });
    }
    exports.spawn = spawn2;
  }
});

// node_modules/threads/dist/master/index.js
var require_master2 = __commonJS({
  "node_modules/threads/dist/master/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Worker = exports.BlobWorker = exports.isWorkerRuntime = exports.Thread = exports.spawn = exports.Pool = void 0;
    var implementation_1 = require_implementation_browser();
    Object.defineProperty(exports, "isWorkerRuntime", { enumerable: true, get: function() {
      return implementation_1.isWorkerRuntime;
    } });
    var pool_1 = require_pool();
    Object.defineProperty(exports, "Pool", { enumerable: true, get: function() {
      return pool_1.Pool;
    } });
    var spawn_1 = require_spawn();
    Object.defineProperty(exports, "spawn", { enumerable: true, get: function() {
      return spawn_1.spawn;
    } });
    var thread_1 = require_thread();
    Object.defineProperty(exports, "Thread", { enumerable: true, get: function() {
      return thread_1.Thread;
    } });
    exports.BlobWorker = implementation_1.getWorkerImplementation().blob;
    exports.Worker = implementation_1.getWorkerImplementation().default;
  }
});

// node_modules/is-observable/index.js
var require_is_observable = __commonJS({
  "node_modules/is-observable/index.js"(exports, module) {
    "use strict";
    module.exports = (value) => {
      if (!value) {
        return false;
      }
      if (typeof Symbol.observable === "symbol" && typeof value[Symbol.observable] === "function") {
        return value === value[Symbol.observable]();
      }
      if (typeof value["@@observable"] === "function") {
        return value === value["@@observable"]();
      }
      return false;
    };
  }
});

// node_modules/threads/dist/worker/implementation.browser.js
var require_implementation_browser2 = __commonJS({
  "node_modules/threads/dist/worker/implementation.browser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var isWorkerRuntime = function isWorkerRuntime2() {
      const isWindowContext = typeof self !== "undefined" && typeof Window !== "undefined" && self instanceof Window;
      return typeof self !== "undefined" && self.postMessage && !isWindowContext ? true : false;
    };
    var postMessageToMaster = function postMessageToMaster2(data, transferList) {
      self.postMessage(data, transferList);
    };
    var subscribeToMasterMessages = function subscribeToMasterMessages2(onMessage) {
      const messageHandler = (messageEvent) => {
        onMessage(messageEvent.data);
      };
      const unsubscribe2 = () => {
        self.removeEventListener("message", messageHandler);
      };
      self.addEventListener("message", messageHandler);
      return unsubscribe2;
    };
    exports.default = {
      isWorkerRuntime,
      postMessageToMaster,
      subscribeToMasterMessages
    };
  }
});

// node_modules/threads/dist/worker/index.js
var require_worker = __commonJS({
  "node_modules/threads/dist/worker/index.js"(exports) {
    "use strict";
    var __awaiter6 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.expose = exports.isWorkerRuntime = exports.Transfer = exports.registerSerializer = void 0;
    var is_observable_1 = __importDefault(require_is_observable());
    var common_1 = require_common();
    var transferable_1 = require_transferable();
    var messages_1 = require_messages();
    var implementation_1 = __importDefault(require_implementation_browser2());
    var common_2 = require_common();
    Object.defineProperty(exports, "registerSerializer", { enumerable: true, get: function() {
      return common_2.registerSerializer;
    } });
    var transferable_2 = require_transferable();
    Object.defineProperty(exports, "Transfer", { enumerable: true, get: function() {
      return transferable_2.Transfer;
    } });
    exports.isWorkerRuntime = implementation_1.default.isWorkerRuntime;
    var exposeCalled = false;
    var activeSubscriptions = /* @__PURE__ */ new Map();
    var isMasterJobCancelMessage = (thing) => thing && thing.type === messages_1.MasterMessageType.cancel;
    var isMasterJobRunMessage = (thing) => thing && thing.type === messages_1.MasterMessageType.run;
    var isObservable2 = (thing) => is_observable_1.default(thing) || isZenObservable(thing);
    function isZenObservable(thing) {
      return thing && typeof thing === "object" && typeof thing.subscribe === "function";
    }
    function deconstructTransfer(thing) {
      return transferable_1.isTransferDescriptor(thing) ? { payload: thing.send, transferables: thing.transferables } : { payload: thing, transferables: void 0 };
    }
    function postFunctionInitMessage() {
      const initMessage = {
        type: messages_1.WorkerMessageType.init,
        exposed: {
          type: "function"
        }
      };
      implementation_1.default.postMessageToMaster(initMessage);
    }
    function postModuleInitMessage(methodNames) {
      const initMessage = {
        type: messages_1.WorkerMessageType.init,
        exposed: {
          type: "module",
          methods: methodNames
        }
      };
      implementation_1.default.postMessageToMaster(initMessage);
    }
    function postJobErrorMessage(uid, rawError) {
      const { payload: error, transferables } = deconstructTransfer(rawError);
      const errorMessage = {
        type: messages_1.WorkerMessageType.error,
        uid,
        error: common_1.serialize(error)
      };
      implementation_1.default.postMessageToMaster(errorMessage, transferables);
    }
    function postJobResultMessage(uid, completed, resultValue) {
      const { payload, transferables } = deconstructTransfer(resultValue);
      const resultMessage = {
        type: messages_1.WorkerMessageType.result,
        uid,
        complete: completed ? true : void 0,
        payload
      };
      implementation_1.default.postMessageToMaster(resultMessage, transferables);
    }
    function postJobStartMessage(uid, resultType) {
      const startMessage = {
        type: messages_1.WorkerMessageType.running,
        uid,
        resultType
      };
      implementation_1.default.postMessageToMaster(startMessage);
    }
    function postUncaughtErrorMessage(error) {
      try {
        const errorMessage = {
          type: messages_1.WorkerMessageType.uncaughtError,
          error: common_1.serialize(error)
        };
        implementation_1.default.postMessageToMaster(errorMessage);
      } catch (subError) {
        console.error("Not reporting uncaught error back to master thread as it occured while reporting an uncaught error already.\nLatest error:", subError, "\nOriginal error:", error);
      }
    }
    function runFunction(jobUID, fn, args) {
      return __awaiter6(this, void 0, void 0, function* () {
        let syncResult;
        try {
          syncResult = fn(...args);
        } catch (error) {
          return postJobErrorMessage(jobUID, error);
        }
        const resultType = isObservable2(syncResult) ? "observable" : "promise";
        postJobStartMessage(jobUID, resultType);
        if (isObservable2(syncResult)) {
          const subscription = syncResult.subscribe((value) => postJobResultMessage(jobUID, false, common_1.serialize(value)), (error) => {
            postJobErrorMessage(jobUID, common_1.serialize(error));
            activeSubscriptions.delete(jobUID);
          }, () => {
            postJobResultMessage(jobUID, true);
            activeSubscriptions.delete(jobUID);
          });
          activeSubscriptions.set(jobUID, subscription);
        } else {
          try {
            const result = yield syncResult;
            postJobResultMessage(jobUID, true, common_1.serialize(result));
          } catch (error) {
            postJobErrorMessage(jobUID, common_1.serialize(error));
          }
        }
      });
    }
    function expose2(exposed) {
      if (!implementation_1.default.isWorkerRuntime()) {
        throw Error("expose() called in the master thread.");
      }
      if (exposeCalled) {
        throw Error("expose() called more than once. This is not possible. Pass an object to expose() if you want to expose multiple functions.");
      }
      exposeCalled = true;
      if (typeof exposed === "function") {
        implementation_1.default.subscribeToMasterMessages((messageData) => {
          if (isMasterJobRunMessage(messageData) && !messageData.method) {
            runFunction(messageData.uid, exposed, messageData.args.map(common_1.deserialize));
          }
        });
        postFunctionInitMessage();
      } else if (typeof exposed === "object" && exposed) {
        implementation_1.default.subscribeToMasterMessages((messageData) => {
          if (isMasterJobRunMessage(messageData) && messageData.method) {
            runFunction(messageData.uid, exposed[messageData.method], messageData.args.map(common_1.deserialize));
          }
        });
        const methodNames = Object.keys(exposed).filter((key) => typeof exposed[key] === "function");
        postModuleInitMessage(methodNames);
      } else {
        throw Error(`Invalid argument passed to expose(). Expected a function or an object, got: ${exposed}`);
      }
      implementation_1.default.subscribeToMasterMessages((messageData) => {
        if (isMasterJobCancelMessage(messageData)) {
          const jobUID = messageData.uid;
          const subscription = activeSubscriptions.get(jobUID);
          if (subscription) {
            subscription.unsubscribe();
            activeSubscriptions.delete(jobUID);
          }
        }
      });
    }
    exports.expose = expose2;
    if (typeof self !== "undefined" && typeof self.addEventListener === "function" && implementation_1.default.isWorkerRuntime()) {
      self.addEventListener("error", (event) => {
        setTimeout(() => postUncaughtErrorMessage(event.error || event), 250);
      });
      self.addEventListener("unhandledrejection", (event) => {
        const error = event.reason;
        if (error && typeof error.message === "string") {
          setTimeout(() => postUncaughtErrorMessage(error), 250);
        }
      });
    }
    if (typeof process !== "undefined" && typeof process.on === "function" && implementation_1.default.isWorkerRuntime()) {
      process.on("uncaughtException", (error) => {
        setTimeout(() => postUncaughtErrorMessage(error), 250);
      });
      process.on("unhandledRejection", (error) => {
        if (error && typeof error.message === "string") {
          setTimeout(() => postUncaughtErrorMessage(error), 250);
        }
      });
    }
  }
});

// node_modules/threads/dist/index.js
var require_dist = __commonJS({
  "node_modules/threads/dist/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Transfer = exports.DefaultSerializer = exports.expose = exports.registerSerializer = void 0;
    var common_1 = require_common();
    Object.defineProperty(exports, "registerSerializer", { enumerable: true, get: function() {
      return common_1.registerSerializer;
    } });
    __exportStar(require_master2(), exports);
    var index_1 = require_worker();
    Object.defineProperty(exports, "expose", { enumerable: true, get: function() {
      return index_1.expose;
    } });
    var serializers_1 = require_serializers();
    Object.defineProperty(exports, "DefaultSerializer", { enumerable: true, get: function() {
      return serializers_1.DefaultSerializer;
    } });
    var transferable_1 = require_transferable();
    Object.defineProperty(exports, "Transfer", { enumerable: true, get: function() {
      return transferable_1.Transfer;
    } });
  }
});

// node_modules/threads/index.mjs
var import_dist = __toESM(require_dist(), 1);
var registerSerializer = import_dist.default.registerSerializer;
var spawn = import_dist.default.spawn;
var BlobWorker = import_dist.default.BlobWorker;
var DefaultSerializer = import_dist.default.DefaultSerializer;
var Pool = import_dist.default.Pool;
var Thread = import_dist.default.Thread;
var Transfer = import_dist.default.Transfer;
var Worker2 = import_dist.default.Worker;

// node_modules/threads/worker.mjs
var import_worker = __toESM(require_worker(), 1);
var expose = import_worker.default.expose;
var registerSerializer2 = import_worker.default.registerSerializer;
var Transfer2 = import_worker.default.Transfer;

// node_modules/@sdeverywhere/runtime-async/dist/index.js
async function spawnAsyncModelRunner(workerSpec) {
  if (workerSpec["path"]) {
    return spawnAsyncModelRunnerWithWorker(new Worker2(workerSpec["path"]));
  } else {
    return spawnAsyncModelRunnerWithWorker(BlobWorker.fromText(workerSpec["source"]));
  }
}
async function spawnAsyncModelRunnerWithWorker(worker) {
  const modelWorker2 = await spawn(worker);
  const initResult = await modelWorker2.initModel();
  const modelListing = initResult.modelListing ? new ModelListing(initResult.modelListing) : void 0;
  const params2 = new BufferedRunModelParams(modelListing);
  let running = false;
  let terminated = false;
  return {
    createOutputs: () => {
      return new Outputs(initResult.outputVarIds, initResult.startTime, initResult.endTime, initResult.saveFreq);
    },
    runModel: async (inputs, outputs, options) => {
      if (terminated) {
        throw new Error("Async model runner has already been terminated");
      } else if (running) {
        throw new Error("Async model runner only supports one `runModel` call at a time");
      } else {
        running = true;
      }
      params2.updateFromParams(inputs, outputs, options);
      let ioBuffer;
      try {
        ioBuffer = await modelWorker2.runModel(Transfer(params2.getEncodedBuffer()));
      } finally {
        running = false;
      }
      params2.updateFromEncodedBuffer(ioBuffer);
      params2.finalizeOutputs(outputs);
      return outputs;
    },
    terminate: () => {
      if (terminated) {
        return Promise.resolve();
      } else {
        terminated = true;
        return Thread.terminate(modelWorker2);
      }
    }
  };
}
var initGeneratedModel;
var runnableModel;
var params = new BufferedRunModelParams();
var modelWorker = {
  async initModel() {
    if (runnableModel) {
      throw new Error("RunnableModel was already initialized");
    }
    const generatedModel = await initGeneratedModel();
    runnableModel = createRunnableModel(generatedModel);
    return {
      outputVarIds: runnableModel.outputVarIds,
      modelListing: runnableModel.modelListing,
      startTime: runnableModel.startTime,
      endTime: runnableModel.endTime,
      saveFreq: runnableModel.saveFreq,
      outputRowLength: runnableModel.numSavePoints
    };
  },
  runModel(ioBuffer) {
    if (!runnableModel) {
      throw new Error("RunnableModel must be initialized before running the model in worker");
    }
    params.updateFromEncodedBuffer(ioBuffer);
    runnableModel.runModel(params);
    return Transfer2(ioBuffer);
  }
};
function exposeModelWorker(init) {
  initGeneratedModel = init;
  expose(modelWorker);
}
export {
  exposeModelWorker,
  spawnAsyncModelRunner
};
//# sourceMappingURL=@sdeverywhere_runtime-async.js.map
